/*******************************************************************************************************
			"LLVM IR Transformation Pass"
Author:      Aditi Raste and Shreya Singh
Created on:  7 May 2021
Description: This code transforms LLVM IR generated by -instnamer and -mem2reg passes into a simplified form.
	     The pass performs the following taks:
	     1. Every IR instruction is translated into an assignment statement.
	     2. LHS and RHS are computed and stored from these translated assignment statements.
	     3. LHS and RHS are maintained along with their indirection levels.
             4. A Phi instruction is translated into a list of assignment statements and are executed in parallel.
	     5. Performs optimization on the IR that has the same effect of local copy propoagation and local dead code elimination.
Last Updated: 
Current Status: 
**********************************************************************************************************/

#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/Instructions.h"
#include <bits/stdc++.h>
#include <cxxabi.h>
#include "llvm/IR/Module.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/IR/InstrTypes.h"
#include "spatial/InstModel/LFCPAInstModel/LFCPAInstModel.h"
#include "spatial/InstInfo/InstInfo.h"
#include "spatial/Utils/CFGUtils.h"
#include "llvm/ADT/BitVector.h"
#include <string>

using namespace llvm;
using namespace spatial;

/*-- Global Definitions --*/
static long long int instrCounter = 1;
spatial::Token *TK;
spatial::TokenWrapper TW;
spatial:: LFCPAInstModel *IM;
Function* globalCurrFun;  /*Needed to modify names of fun arguments*/

class Array {
        std::map<std::pair<Token*, std::string>, bool> infoArrayMap;
public:
	void setArray(Token*, std::string);
	bool checkArray(Token*, std::string);	
	void printInfoArrayMap();
};

///Prints whether the Token is an Array
void Array::printInfoArrayMap() {
#if defined(TRACE) || defined(PRINT) 
	llvm::outs() << "\n Printing InfoArrayMap";
#endif
	for ( auto m : infoArrayMap) 
		std::pair<Token*, std::string> Op = m.first;
}

///Sets the array field in InfoArrayMap structure
void Array::setArray(Token* op, std::string fieldIndx) { 
		infoArrayMap[std::make_pair(op, fieldIndx)] = true;
}

///Checks if the Token is an Array
bool Array::checkArray(Token* op, std::string fieldIndx) { 
	for (auto arr : infoArrayMap) {
		if ((arr.first.first->getName() == op->getName()) and fieldIndx == arr.first.second)
			return true;
	}
	return false;
}
Array objArray;
//--------------------------------------------------------------------------------------------------

class Structure {
	std::map<long long int, std::string> structIndexLhs, structIndexRhs ;
	std::map<long long int, std::vector<std::tuple<int, Token*, std::string, int>>> insPhiRhsIndx;
	std::map<Instruction*, std::vector<std::tuple<int, Token*, std::string, int>>> insIcmpRhsIndx;
public:
	void setStructFieldIndxLhs(std::string);
	void setStructFieldIndxRhs(std::string);
        void setInsPhiRhsOpd(int, Token*, std::string,int);
	void setInsIcmpRhsOpd(Instruction*, int, Token*, std::string,int);  
	std::string getStructFieldIndxLhs(long long int);
	std::string getStructFieldIndxRhs(long long int);
	std::vector<std::tuple<int, Token*, std::string, int>> fetchPhiRhsOpd(long long int);
	std::vector<std::tuple<int, Token*, std::string, int>> fetchIcmpRhsOpd(Instruction*);
};

Structure objStruct;

void Structure::setStructFieldIndxLhs(std::string index) { structIndexLhs[instrCounter] = index; }

void Structure::setStructFieldIndxRhs(std::string index) { structIndexRhs[instrCounter] = index; }

/*Store index of GEP operand in Phi Instr*/
void Structure::setInsPhiRhsOpd(int B, Token *T, std::string index, int indir) {
	 insPhiRhsIndx[instrCounter].push_back(std::make_tuple(B,T,index,indir)); 
}

/*Store index of GEP operand in ICMP Instr*/
void Structure::setInsIcmpRhsOpd(Instruction* ins, int B, Token *T, std::string index, int indir) { 
	insIcmpRhsIndx[ins].push_back(std::make_tuple(B,T,index,indir)); 
}

std::string Structure::getStructFieldIndxLhs(long long int counter) { return structIndexLhs[counter]; }

std::string Structure::getStructFieldIndxRhs(long long int counter) { return structIndexRhs[counter]; }

std::vector<std::tuple<int, Token*, std::string,int>> Structure::fetchPhiRhsOpd(long long int counter) {
	return insPhiRhsIndx[counter];
}

std::vector<std::tuple<int, Token*, std::string,int>> Structure::fetchIcmpRhsOpd(Instruction* I) {
	return insIcmpRhsIndx[I];
}
//--------------------------------------------------------------------------------------------------------
enum InstTy { insUse, insKill, insCall, insPhi, insGEP, gopLhs, gopRhs, fieldLhs, fieldRhs, insBitcast, bitcastRhs, phiRhsIndx/*GEP in Phi*/, insFunPtr, ArgFieldRhs, RetFieldRhs };
bool retFlag = false;  /* Set only if return stmt is considered */
bool insFlag = false;  /* Set only is instr is considered for analysis. Required for Skip instr */
bool callFlag = false; /* Set only if call instr is considered */
bool cmpFlag = false;  /* Set only if compare instr is considered */
std::set<Token*> arrOperand; /* Store array operands. Required to compute Pin_start */
bool funPtrFlag = false; /* Set only if call is indirect */


class fetchLR {
protected:
 	std::pair<Token*, int > LHS;
        std::vector<std::pair<Token*, int >> RHS;
	BitVector InstTy;
	unsigned int Length;
public:
	fetchLR();
	void setUse();
	void setKill();
	void setPhi();
	void setGEP();
	void setGOPLhs();
	void setGOPRhs();
	void setCall();
	void setFieldLhs();
	void setFieldRhs();
        void setBitcast();
	void setBitcastRhs();
	void setPhiRhsIndx();
	void setInsFunPtr();
	void setArgFieldRhs();
	void setRetFieldRhs();
	bool getUse();
	bool getKill();
	bool getPhi();
	bool getGEP();
	bool getGOPLhs();
	bool getGOPRhs();
	bool getCall();
	bool getFieldLhs();
	bool getFieldRhs();
	bool getBitcast();
	bool getBitcastRhs();
	bool getPhiRhsIndx();
	bool getInsFunPtr();
	bool getArgFieldRhs();
	bool getRetFieldRhs();
	fetchLR metaDataSetter(Instruction*);
	std::pair<Token*, int> getLHS();
	std::vector<std::pair<Token*, int>> getRHS();
	fetchLR metaDataReturnIns(Instruction*);
	fetchLR metaDataCmpIns(Instruction*);  
	fetchLR metaDataPrintfIns(Instruction*);
	std::string demangle(const char*);
	std::string getOriginalName(Function*);
	fetchLR getArgStore(Value* LHS, Value* RHS);
	std::vector<Token*> mapReturnArg(Function *);
	void printOperands(fetchLR);
	bool operator == (fetchLR &);
	fetchLR getRetArgStore(Token*, Token*);
};

bool fetchLR::operator == (fetchLR & O1) {
  bool flag = true;
  if (this->getLHS().first == O1.getLHS().first) {
	std::vector<std::pair<Token*, int >> oRhs = this->getRHS();
	std::vector<std::pair<Token*, int >> o1Rhs = O1.getRHS();

	for (int i = 0; i < oRhs.size(); i++) {
		if (oRhs[i].first != o1Rhs[i].first) {
			flag = false;	
			break;
		}
	}//end for
  }
  else
	flag = false;
  return flag;
}


void fetchLR::printOperands(fetchLR Ob) {
  llvm::outs() << "\n Inside printOperands..........";
  std::pair<Token*, int> tempLHS;
  Token* lhsVal;
  int indirLhs;
  std::vector<std::pair<Token*, int>> rhsVector;
  std::set<std::pair<Token*, std::string>> OUTofInst, INofInst, INofInstPrev;
  std::string indxLHS;

  tempLHS = Ob.getLHS();
  lhsVal = tempLHS.first;  
  indirLhs = tempLHS.second;
  if (lhsVal != NULL)
	llvm::outs() << "\n Lhs: <"<<lhsVal->getName()<<", "<<indirLhs<<">";
  rhsVector = Ob.getRHS();
  for (std::vector<std::pair<Token*, int>>::iterator r = rhsVector.begin(); r!=rhsVector.end(); r++) {					
	std::pair<Token*, int > rhsVal = *r;
	llvm::outs() << "\n Rhs: <"<< rhsVal.first->getName() << ", "<<rhsVal.second <<">";
   }
}

fetchLR::fetchLR() {
  this->Length = 15;
  InstTy = llvm::BitVector(this->Length, false);
}

std::list<fetchLR> ArgStore; /* Mapped formal and actual arguments*/ 
std::list<fetchLR> ReturnArgStore; /* Mapped Return argument */
bool flagArgs = false;
bool flagRetArg = false; //set to true if return args are mapped

void fetchLR::setUse() { InstTy.set(insUse); }

void fetchLR::setKill() { InstTy.set(insKill); }

void fetchLR::setPhi() { InstTy.set(insPhi); }

void fetchLR::setGEP() { InstTy.set(insGEP); }

void fetchLR::setGOPLhs() { InstTy.set(gopLhs); }

void fetchLR::setGOPRhs() { InstTy.set(gopRhs); }

void fetchLR::setCall() { InstTy.set(insCall); }

void fetchLR::setFieldLhs() { InstTy.set(fieldLhs); }

void fetchLR::setFieldRhs() { InstTy.set(fieldRhs); }

void fetchLR::setBitcast() { InstTy.set(insBitcast); }

void fetchLR::setBitcastRhs() { InstTy.set(bitcastRhs); }

void fetchLR::setPhiRhsIndx() { InstTy.set(phiRhsIndx); }

void fetchLR::setInsFunPtr() { InstTy.set(insFunPtr); }

void fetchLR::setArgFieldRhs() { InstTy.set(ArgFieldRhs); }

void fetchLR::setRetFieldRhs() { InstTy.set(RetFieldRhs); }

bool fetchLR::getUse() { return InstTy.test(insUse); }

bool fetchLR::getKill() { return InstTy.test(insKill); }

bool fetchLR::getPhi() { return InstTy.test(insPhi); }

bool fetchLR::getGEP() { return InstTy.test(insGEP); }

bool fetchLR::getGOPLhs() { return InstTy.test(gopLhs); }

bool fetchLR::getGOPRhs() { return InstTy.test(gopRhs); }

bool fetchLR::getCall() { return InstTy.test(insCall); }

bool fetchLR::getFieldLhs() { return InstTy.test(fieldLhs); }

bool fetchLR::getFieldRhs() { return InstTy.test(fieldRhs); }

bool fetchLR::getBitcast() { return InstTy.test(insBitcast); }

bool fetchLR::getBitcastRhs() { return InstTy.test(bitcastRhs); }

bool fetchLR::getPhiRhsIndx() { return InstTy.test(phiRhsIndx); }

bool fetchLR::getInsFunPtr() { return InstTy.test(insFunPtr); }

bool fetchLR::getArgFieldRhs() { return InstTy.test(ArgFieldRhs); }

bool fetchLR::getRetFieldRhs() { return InstTy.test(RetFieldRhs); }

std::pair<Token*, int> fetchLR::getLHS() { return (this->LHS);}

std::vector<std::pair<Token*, int>> fetchLR::getRHS() {	return (this->RHS); }

///Computes the Tokens for LHS and RHS for an LLVM IR Instruction
fetchLR fetchLR::metaDataSetter(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
	llvm::outs() << "\n Inside function metaDataSetter";
#endif
	insFlag = false;
	RHS.clear();
	int indirLhs, indirRhs;

	if (StoreInst *SI = dyn_cast<StoreInst>(I)) {
	#if defined(TRACE) || defined(PRINT) 
	   llvm::outs() << "\n Instr is a STORE ";
	#endif

     	   std::vector<Token*> vecStoreIns = IM->extractToken(SI);

	   if (!vecStoreIns.empty()) {
		#ifdef PRINT
			llvm::outs() << "\n Store not empty";
		#endif
		insFlag = true; //Instr is considered and not skipped
		Token* opLhs = vecStoreIns[0];
		Token* opRhs = vecStoreIns[1];

		std::vector<int> vecIndir = IM->extractRedirections(I);
 		indirLhs = vecIndir[0]; indirRhs = vecIndir[1];

		if (!isa<Instruction>(SI->getPointerOperand())){
		    if (BitCastOperator* BO = dyn_cast<BitCastOperator>(SI->getPointerOperand())){
		        Token* DestTy = new Token(BO->getDestTy());
		        if (DestTy->isBasePointerType()){
                   	    Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
		            spatial::Token* LHSTok =  new spatial::Token(BCVar);
                	    LHSTok->setIndex(LHSTok, "[0]");
                	    LHSTok = TW.getToken(LHSTok);
                	    objStruct.setStructFieldIndxLhs(LHSTok->getFieldIndex());			
                	    this->setFieldLhs();
                	    opLhs = LHSTok;
			    opLhs->setIsOpBitcast(); //set the OpBitcast bit
		        }
		    }
		}
		if (!isa<Instruction>(SI->getOperand(0))){
			
			 if (BitCastOperator* BO = dyn_cast<BitCastOperator>(SI->getOperand(0))){
		        	Token* DestTy = new Token(BO->getDestTy());
		       		Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
                    		spatial::Token* RHSTok =  new spatial::Token(BCVar);
                    		RHSTok->setIndex(RHSTok, "[0]");
		                RHSTok = TW.getToken(RHSTok);
                    		objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
                    		this->setFieldRhs();
                    		opRhs = RHSTok;
		    		opRhs->setIsOpBitcast(); //set the OpBitcast bit
				this->setBitcastRhs();							
		        }
		}
		if (isa<GEPOperator>(SI->getOperand(0))) { /* First check if Lhs or Rhs is GEP Operator */
		#ifdef PRINT
		    llvm::outs() << "\n Rhs is GEP Operator ";
		#endif
		    this->setGOPRhs();
		    GEPOperator *GOP = dyn_cast<GEPOperator>(SI->getOperand(0));

 		    if (isa<GlobalVariable>(GOP->getOperand(0))) { /*Distinguishing between two kinds of GEP STORE instrs */
		    	this->setFieldRhs(); 
			if (GOP->getOperand(0)->getType()->getContainedType(0)->isArrayTy())
				indirRhs = 0;
			else    
				indirRhs = 1;
			#ifdef PRINT
			    	llvm::outs() <<"\n Name : "<< opRhs->getName() <<"  Field Index: "<< opRhs->getFieldIndex();
			#endif
		    	objStruct.setStructFieldIndxRhs(opRhs->getFieldIndex());
		    }
		}
		if (isa<GEPOperator>(SI->getOperand(1)) and opLhs->isGlobalVar()/*Addedin bchmk testing as indices were printed*/) {  
		#ifdef PRINT
		    llvm::outs() << " \n Lhs is GEP operator";
		#endif
		    this->setGOPLhs();
		    GEPOperator *GOP = dyn_cast<GEPOperator>(SI->getOperand(1));
		
		    /* SetArray if operand is Global and an array*/
		    if (IM->isArrayType(GOP) and  opLhs->isGlobalVar()) {
			#ifdef PRINT
				llvm::outs() << "\n Store to an array";	
			#endif
			opLhs->setIsArray();
			objArray.setArray(opLhs, opLhs->getFieldIndex());
		    }			
		    if (isa<GlobalVariable>(GOP->getOperand(0)) and isa<GEPOperator>(SI->getOperand(0))) {
			/* To handle the case s1.s2.f = &s1.s2.n*/
			this->setFieldLhs();
			indirLhs = 1;
			if (isa<GlobalVariable>(GOP->getOperand(1)))			
				indirRhs = 0;
		    	objStruct.setStructFieldIndxLhs(opLhs->getFieldIndex());
		    }
 		    if (isa<GlobalVariable>(GOP->getOperand(0))) { /*Distinguishing between two kinds of GEP STORE instrs */
		    	this->setFieldLhs();
			indirLhs = 1;
		    	objStruct.setStructFieldIndxLhs(opLhs->getFieldIndex());			
		    }
   	        }
	        RHS.push_back(std::make_pair(opRhs, indirRhs));
	        LHS = std::make_pair(opLhs, indirLhs);			
	   }//end empty vec
	}//end STORE
	else if (LoadInst *LI = dyn_cast<LoadInst>(I))	{
	#if defined(TRACE) || defined(PRINT) 
	    llvm::outs() << "\n Instr is a LOAD ";
	#endif
     	    std::vector<Token*> vecLoadIns = IM->extractToken(LI);
		
	    if (!vecLoadIns.empty()) {
		insFlag = true;	
		Token* opLhs = vecLoadIns[0]; 
		Token* opRhs = vecLoadIns[1];

		std::vector<int> vecIndir = IM->extractRedirections(I);
 		indirLhs = vecIndir[0]; indirRhs = vecIndir[1];

		if (!isa<Instruction>(LI->getPointerOperand())){
		    if (BitCastOperator* BO = dyn_cast<BitCastOperator>(LI->getPointerOperand())){
		        Token* DestTy = new Token(BO->getDestTy());
                int Memtype = -1;
                if (DestTy -> isValPointerType() && DestTy->getValue()->getType()->getNumContainedTypes() > 0)
                    Memtype = 0; // struct
                else if (DestTy -> isValPointerType() && DestTy->getValue()->getType()->getNumContainedTypes() == 0)
                    Memtype = 1; // var
                else if (DestTy -> isBasePointerType())
                    Memtype = 2; // array
		        if (Memtype != 1){
 	                	Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
	                	spatial::Token* RHSTok =  new spatial::Token(BCVar);
	                	RHSTok->setIndex(RHSTok, "[0]");
	                	RHSTok = TW.getToken(RHSTok);
	                	objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
	                	this->setFieldRhs();
	                	opRhs = RHSTok;
			        opRhs->setIsOpBitcast();
		        }
		    }
		}		    
		if (isa<GEPOperator>(LI->getPointerOperand()) and opRhs->isGlobalVar()/*Added due to case in benchmarks*/) {
		/* First check if Rhs is GEP Operator */
		#ifdef PRINT
		    llvm::outs() << "\n Rhs is GEP Operator ";
		#endif
		    this->setGOPRhs();
		    GEPOperator *GOP = dyn_cast<GEPOperator>(LI->getPointerOperand());

 		    /*Check for Bitcast in GEP Load*/
		    if (true || isa<GlobalVariable>(GOP->getOperand(0))) {
		      if (BitCastOperator* BO = dyn_cast<BitCastOperator>(GOP->getOperand(0))) {
			#ifdef PRINT
				llvm::outs() << "\n GEP operand is a Bitcast";
			#endif
			std::string gopIndx = TK->getIndex(GOP); //store GEP operator index
			Token* DestTy = new Token(BO->getDestTy());
                	Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
                    	spatial::Token* RHSTok =  new spatial::Token(BCVar);
                    	RHSTok->setIndex(RHSTok, "[0]"+ gopIndx); //RHSIndex = "[0]" + gopIndx;
                    	RHSTok = TW.getToken(RHSTok);
                    	objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
                    	this->setFieldRhs();
                    	opRhs = RHSTok;  	
		     }//end if
		    }//end outer if
		   /* SetArray if operand is Global and an array*/
		    if (IM->isArrayType(GOP) and  opRhs->isGlobalVar()) {
			#ifdef PRINT
				llvm::outs() << "\n Load from an array";
			#endif	
			opRhs->setIsArray();
			objArray.setArray(opRhs, opRhs->getFieldIndex());
		    }
		    if (isa<GlobalVariable>(GOP->getOperand(0))) { /*Distinguishing between two kinds of GEP LOAD instrs */
			this->setFieldRhs(); 
		    	indirRhs = 1;
		    	objStruct.setStructFieldIndxRhs(opRhs->getFieldIndex());
		    }
		}
	        RHS.push_back(std::make_pair(opRhs, indirRhs));
	        LHS = std::make_pair(opLhs, indirLhs);			
	  }//end empty vec
	}//end LOAD
	else if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {
		#if defined(TRACE) || defined(PRINT) 
			llvm::outs() << "\n Instr is a GEP  ";
		#endif
		this->setFieldRhs();
		std::vector<Token*> vecGEPIns = IM->extractToken(GEP);
	
		if (!vecGEPIns.empty()) { 
			insFlag = true;
			this->setGEP();
			Token* opLhs = vecGEPIns[0];
			Token* opRhs = vecGEPIns[1];
			std::vector<int> vecIndir = IM->extractRedirections(I);
 			indirLhs = vecIndir[0]; indirRhs = vecIndir[1];
			LHS = std::make_pair(opLhs, indirLhs);
			objStruct.setStructFieldIndxRhs(opRhs->getFieldIndex());	
			Value* Op = GEP->getOperand(0);
			/* check if GEP operand is an array type(local decl)*/		
		        if (!isa<Instruction>(Op)) {  
                		if (BitCastOperator* BCO = dyn_cast<BitCastOperator>(Op)){
				  #if defined(TRACE) || defined(PRINT) 
				  llvm::outs() << "\n Bitcast instr in a GEP.";
				  #endif
               		          Op = BCO->getOperand(0);
				          	        
                	        if (Op->getType()->getContainedType(0)->isArrayTy()){
				  #if defined(TRACE) || defined(PRINT) 
			          llvm::outs() << "\n Bitcast in a GEP is an array type. ";
		                  #endif
                	          opRhs = TW.getToken(new spatial::Token(Op));
				  opRhs->setIndex(opRhs);
                	        }
				else {
				  #if defined(TRACE) || defined(PRINT) 
			          llvm::outs() << "\n Bitcast in a GEP is not an array type. ";
		                  #endif
				  opRhs = TW.getToken(new spatial::Token(Op));
				  opRhs->setIndex(opRhs);
				}
			    }
                        }
			if (Op->getType()->getContainedType(0)->isArrayTy()) {
				opRhs->setIsArray();
				objArray.setArray(opRhs, opRhs->getFieldIndex());
			}	
			if (GEP->getNumOperands() == 2) {
				  #if defined(TRACE) || defined(PRINT) 
			          llvm::outs() << "\n GEP instruction operand has only one index. ";
		                  #endif
				 opRhs->setIsOneGEPIndx();
			}		       
			RHS.push_back(std::make_pair(opRhs, indirRhs));
		}
	}//end GEP
	else if (BitCastInst *BI = dyn_cast<BitCastInst>(I)) {
		#if defined(TRACE) || defined(PRINT) 
			llvm::outs() << "\n Instr is Bitcast Instruction ";
		#endif
        // x = bitcast y
        // x = y[0]
		Token* DestTy = new Token(BI->getDestTy());
		std::vector<Token*> VecBitCastInstToken = IM->extractToken(BI);
		std::vector<int> VecBitCastInstIndir = IM->extractRedirections(I);
		this->setBitcast();
		
		if (!VecBitCastInstToken.empty()) {
		   	insFlag = true;
			LHS = std::make_pair(VecBitCastInstToken[0], VecBitCastInstIndir[0]);
        		spatial::Token* RHSTok =  new spatial::Token(VecBitCastInstToken[1]);
	                RHSTok->setIndex(RHSTok, "[0]");
			RHSTok = TW.getToken(RHSTok);
			if (VecBitCastInstToken[1]->getIsAlloca())
				RHSTok->setIsAlloca();
			RHS.push_back(std::make_pair(RHSTok, VecBitCastInstIndir[1]));
			objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
		}
	}
	else if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {
 		#if defined(TRACE) || defined(PRINT) 
			llvm::outs() << "\n Inst is an ALLOCA Inst. ";
		#endif
		std::vector<Token*> vecAIIns = IM->extractToken(AI);
        }//end alloca
	else if (PHINode *PHI = dyn_cast<PHINode>(I)) {
		#if defined(TRACE) || defined(PRINT) 
			llvm::outs() << "\n Inst is Phi Instruction";
		#endif
		std::vector<Token*> vecPHIIns = IM->extractToken(PHI);
		
		if (vecPHIIns.size() > 1)	{ 
		   this->setPhi();
		   insFlag = true;
	 	   std::vector<int> vecIndir = IM->extractRedirections(I);
 		   indirLhs = vecIndir[0]; 
		   Token* opLhs = vecPHIIns[0];  

		   LHS = std::make_pair(opLhs, indirLhs);

        	   for (int i = 1; i < vecPHIIns.size(); i++) { 
	  	      Token *opRhs = vecPHIIns[i];	
		      if (opRhs->getName() != "NULL") {
		        if (!isa<Instruction>(I->getOperand(i-1))) {  
			// operands of phi could be GEP or BITCAST operators
		           if (isa<BitCastOperator>(I->getOperand(i-1))){   //Phi operand is bitcast operator
				#if defined(TRACE) || defined(PRINT) 
			          llvm::outs() << "\n Bitcast in a PHI Instr. ";
		                #endif
				BitCastOperator* BCO = dyn_cast<BitCastOperator>(I->getOperand(i-1));
			
				if (isa<GEPOperator>(BCO->getOperand(0)))  {
				  #if defined(TRACE) || defined(PRINT) 
				    llvm::outs() << "\n GEP within a Bitcast in a PHI Instr. ";
		                  #endif
				   GEPOperator *GEPOp = dyn_cast<GEPOperator>(BCO->getOperand(0));
				   std::string opIndx = TK->getIndex(GEPOp);	
				   opRhs = TW.getToken(new spatial::Token(GEPOp->getOperand(0)));
				   opRhs->setIndex(GEPOp);
				   indirRhs = 0;
				   objStruct.setInsPhiRhsOpd((i-1),opRhs, opRhs->getFieldIndex(),indirRhs);
				   RHS.push_back(std::make_pair(opRhs, indirRhs));
				}  
				else {
				   #if defined(TRACE) || defined(PRINT) 
				    llvm::outs() << "\n Normal Bitcast in a PHI Instr. ";
		                   #endif
				    opRhs = TW.getToken(new spatial::Token(BCO->getOperand(0)));
				    opRhs->setIndex(opRhs, "[0]");
				    indirRhs = 1;
				    objStruct.setInsPhiRhsOpd((i-1),opRhs, opRhs->getFieldIndex(),indirRhs);
				    RHS.push_back(std::make_pair(opRhs, indirRhs));
				}
			}
			else if (isa<GEPOperator>(I->getOperand(i-1))) { //Phi operand is GEP operator
				  #if defined(TRACE) || defined(PRINT) 
					llvm::outs() << "\n PHI operand_"<<i<<" is a GEP Operator";
		                  #endif
	
				if (!isa<Instruction>(I->getOperand(i-1))) {
					this->setPhiRhsIndx();
					opRhs->setIsPhiGEPOpd();
					indirRhs = 0;
					objStruct.setInsPhiRhsOpd((i-1),opRhs, opRhs->getFieldIndex(),indirRhs);
			  		RHS.push_back(std::make_pair(opRhs, indirRhs));					
				}
			        else {
					indirRhs = 1;
					objStruct.setInsPhiRhsOpd((i-1),opRhs,"",indirRhs);
			  		RHS.push_back(std::make_pair(opRhs, indirRhs));					
				}//end else non-gep							
			}
			else {
				#if defined(TRACE) || defined(PRINT) 
					llvm::outs() << "\n PHI Operand is an formal/input parameter. ";
		                #endif
				if (opRhs->isGlobalVar())
					indirRhs = 0;
				else
					indirRhs = 1;
				objStruct.setInsPhiRhsOpd((i-1),opRhs,"",indirRhs);
				RHS.push_back(std::make_pair(opRhs, indirRhs));
			}
		     }//end if instr
		     else {
				#if defined(TRACE) || defined(PRINT) 
					//llvm::outs() << "\n Normal PHI Instruction. ";
		                #endif

				if (opRhs->isGlobalVar())
					indirRhs = 0;
				else
					indirRhs = 1;
				objStruct.setInsPhiRhsOpd((i-1),opRhs,"",indirRhs);
		  		RHS.push_back(std::make_pair(opRhs, indirRhs));
		     }//end else normal opd	
		   }//end if name not null		
        	  }//end for
		}//end if
	}//end phi
	return *this;
}	

 inline std::string fetchLR::demangle(const char* name)   {
        int status = -1;

        std::unique_ptr<char, void(*)(void*)> res { abi::__cxa_demangle(name, NULL, NULL, &status), std::free };
        return (status == 0) ? res.get() : std::string(name);
 }

 std::string fetchLR::getOriginalName(Function* calledFunction)  {
	std::string emptyString;
	if (calledFunction != nullptr) { 
	        std::string s1 = demangle(calledFunction->getName().str().c_str());
        	size_t found = s1.find('<');
        	size_t found1 = s1.find(' ');
        	if (found!=std::string::npos and found1!=std::string::npos)
        	    s1 = std::string(s1.begin()+found1+1, s1.begin()+found);
        	return s1;
	}
	return emptyString;
 }

///Computes the RHS Tokens for Compare Instruction in LLVM IR
fetchLR fetchLR::metaDataCmpIns(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
  llvm::outs() << "\n Inside metaDataCmpIns....";
#endif
  int indirLhs, indirRhs;
  fetchLR Ob;
  
  if (CmpInst *CM = dyn_cast<CmpInst>(I)) {
   #ifdef PRINT
    llvm::outs() << "\n Instr is a compare";
   #endif

    std::vector<Token*> vecCmpIns = IM->extractToken(CM); 
    indirLhs = 999; indirRhs = 1;
    Token *opRhs, *opLhs;
    Ob.setUse();

    if (!vecCmpIns.empty())	{ 
	cmpFlag = true;
        for (int i = 0; i < vecCmpIns.size(); i++) {
	  opRhs = vecCmpIns[i];

	  if (!isa<Instruction>(I->getOperand(i))) {
		if (isa<GEPOperator>(I->getOperand(i))) {
			#if defined(TRACE) || defined(PRINT) 
			llvm::outs() << "\n Compare Operand is a GEP. ";
		        #endif
			GEPOperator *GEPOp = dyn_cast<GEPOperator>(I->getOperand(i));
			std::string opIndx = TK->getIndex(GEPOp);	
			opRhs = TW.getToken(new spatial::Token(GEPOp->getOperand(0)));
			opRhs->setIndex(GEPOp);
			opRhs->setIsIcmpGEPOpd();
			indirRhs = 0;
			objStruct.setInsIcmpRhsOpd(I,i,opRhs, opRhs->getFieldIndex(),indirRhs);
		  	Ob.RHS.push_back(std::make_pair(opRhs, indirRhs)); 
		}
		else {
			#if defined(TRACE) || defined(PRINT) 
			llvm::outs() << "\n Non-GEP Compare Operand. ";
	                #endif
			objStruct.setInsIcmpRhsOpd(I,i,opRhs, opRhs->getFieldIndex(),indirRhs);
			Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
		}
	  }
	  else {
		#if defined(TRACE) || defined(PRINT) 
		llvm::outs() << "\n Normal Compare OPerand. ";
                #endif
		objStruct.setInsIcmpRhsOpd(I,i,opRhs, opRhs->getFieldIndex(),indirRhs);
		Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
	  }
        }
        Ob.LHS = std::make_pair(opLhs, indirLhs);
    }//end inner if
   }//end outer if
   return Ob;	
}

///Computes the RHS Tokens for Return Instruction in LLVM IR
fetchLR fetchLR::metaDataReturnIns(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
  llvm::outs() << "\n Inside metaDataReturnIns....";
#endif
  int indirLhs, indirRhs;
  fetchLR Ob;
  if (ReturnInst *RI = dyn_cast<ReturnInst>(I))   {
	#ifdef PRINT
	llvm::outs() << "\n Instr is a RETURN ";
	#endif
	std::vector<Token*> vecRetIns = IM->extractToken(RI); 
	Token* opLhs, *opRhs;
	Ob.setUse();

	if (!vecRetIns.empty())	{
	   retFlag = true;
           opRhs = vecRetIns[0];
	   indirLhs = 99; indirRhs = 1;
	   Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
	   Ob.LHS = std::make_pair(opLhs, indirLhs);
	   return Ob;
	}			   
   }//end outer if
   return Ob;
}// end RETURN

fetchLR fetchLR::getArgStore(Value* LHS, Value* RHS) {
 #if defined(TRACE) || defined(PRINT) 
 llvm::outs() << "\n Inside getArgStore....";
 #endif
 fetchLR Ob;
if (!isa<Instruction>(RHS)){ 
   if (isa<GEPOperator>(RHS)) {
    llvm::outs() << "\n GEP OPerator found in call instr.........."<<RHS->getName();
    Ob.setArgFieldRhs(); 
    GEPOperator *GEPOp = dyn_cast<GEPOperator>(RHS);
    spatial::Token* RHSTok = TW.getToken(new spatial::Token(GEPOp->getOperand(0)));
    RHSTok->setIndex(GEPOp);
    Ob.RHS.push_back(std::make_pair(RHSTok, 0));
    //llvm::outs() << "\n GEP OPerator Rhs: "<<RHSTok->getName()<< " index: "<<RHSTok->getFieldIndex();
 }
 else {
  llvm::outs() << "\n Not  GEP arguments in call instr..........";
  spatial::Token* RHSTok = TW.getToken(new Token(RHS));
  Ob.RHS.push_back(std::make_pair(RHSTok, 1));
 }

}
else {
  llvm::outs() << "\n Normal arguments in call instr..........";
  spatial::Token* RHSTok = TW.getToken(new Token(RHS));
  Ob.RHS.push_back(std::make_pair(RHSTok, 1));
 }
  Function* CalledFunction = dyn_cast<Argument>(LHS)->getParent();
  spatial::Token* LHSTok = TW.getToken(new Token(LHS));
  LHSTok->setIsFunArg();  
  LHSTok->setIsGlobal();
  LHSTok->setFunction(CalledFunction);
  Ob.LHS = std::make_pair(LHSTok, 1);
  return Ob;
}

fetchLR fetchLR::getRetArgStore(Token* LHSTK, Token* RHSTK) {
 #if defined(TRACE) || defined(PRINT) 
 llvm::outs() << "\n Inside getRetArgStore.............";
 #endif
 fetchLR Ob;
 Ob.RHS.push_back(std::make_pair(RHSTK, 1));
 Ob.LHS = std::make_pair(LHSTK, 1);
 return Ob;
}


std::vector<Token*> fetchLR::mapReturnArg(Function *F) {
#if defined(TRACE) || defined(PRINT) 
 llvm::outs() << "\n Inside mapReturnArg.......";
#endif
 std::vector<Token*> vecRetToken;
 std::string fName;
 Instruction* Ins, *I;
 bool skipFlag = false;
 for (Function::iterator bb=F->begin(), e=F->end(); e!=bb; ++bb)  {
     BasicBlock* B = &(*bb);
     for (BasicBlock::iterator i=B->begin(), e1=B->end(); i!=e1; ++i) 	{
       	Instruction* ins = &(*i);
	if (isa<ReturnInst>(ins)) {
	    #if defined(TRACE) || defined(PRINT) 
            llvm::outs() << "\n Return instr in callee";
	    #endif
	    ReturnInst *RI = dyn_cast<ReturnInst>(ins);
	    Value *RetVal = RI->getReturnValue();
	    if (RetVal->getType()->isPointerTy()) {
		 #if defined(TRACE) || defined(PRINT) 
	         llvm::outs() << "\n Return Value is Pointer Type. ";
		 #endif
		 if (isa<GEPOperator>(RetVal)) {
			llvm::outs() << "\n RetVal is a GEP Operator";
		        GEPOperator *GOP = dyn_cast<GEPOperator>(RetVal);
			spatial::Token* RHSTok = TW.getToken(new spatial::Token(GOP->getOperand(0)));
			RHSTok->setIndex(GOP);
			RHSTok->setTy(RetVal->getType());
			RHSTok->setIsRetGEP();
			vecRetToken.push_back(RHSTok);
		 }
		 else {
		    llvm::outs() << "\n Normal operand in Return Ins ";
		    spatial::Token* RHSTok = TW.getToken(new Token(RetVal)); 
  		    RHSTok->setIsGlobal();
		    vecRetToken.push_back(RHSTok);     
		 }
            }
            else if (RetVal && !llvm::isa<llvm::ConstantInt>(RetVal)) {
		#if defined(TRACE) || defined(PRINT) 
		llvm::outs() << "\n Return value is not a pointer type. ";
		#endif
                Ins = dyn_cast<Instruction>(RI);
                while(!skipFlag) {  
	         for (Use &U : Ins->operands()) { 
	              Value* v = U.get();  
	              I = dyn_cast<Instruction>(v); 
                      if (I != nullptr) { 
	               if (isa<LoadInst>(I))	    { 
			if (isa<GlobalVariable>(I->getOperand(0)))	{
		           if (I->getOperand(0)->getType()->getContainedType(0)->isPointerTy())  {
		   	      LoadInst *loadI = dyn_cast<LoadInst>(I);
		   	      Value *OpVal = loadI->getOperand(0);
		   	      spatial::Token* RHSTok = TW.getToken(new Token(RetVal));
   	    	              vecRetToken.push_back(RHSTok);
		   	      skipFlag = true;
		            }//end if
		            else  { 
			      skipFlag = true;
			      break;
		            }//end else 
		       }//end if global
 	              }//end if load
	              else {
		         llvm::outs() << "\n NOT A LOAD INSTR"<<*I;
		         skipFlag = true;
	              }	
	           }//end if null ptr
	           else {  
		       skipFlag = true;
		       break;
	           }//end else break
	         }//end for
              }//end while	
             }//end if
         }//end if
     }//end BB for
 }//end F for
  return vecRetToken;
}

///Computes the RHS Tokens for Printf/Scanf Call Instructions in LLVM IR
fetchLR fetchLR::metaDataPrintfIns(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
  llvm::outs() << "\n Inside metaDataPrintfIns....";
#endif
  int indirLhs, indirRhs;
  fetchLR Ob;
  Token* opLhs, *opRhs;

  if (CallInst *CI = dyn_cast<CallInst>(I)) {  
	Function* calledFunction = cast<CallInst>(CI)->getCalledFunction();        
        std::string originalName = getOriginalName(calledFunction);
	if (originalName == "printf") {  
		#if defined(TRACE) || defined(PRINT) 
		llvm::outs() << "\n Call to printf";
		#endif
		Ob.setUse();
		indirLhs = 999; indirRhs = 1;
		std::vector<Token*> vecPrintIns = IM->extractToken(CI);
		if (vecPrintIns.size() > 1) {
		   callFlag = true;
	           for (int i = 1; i < vecPrintIns.size(); i++) {
			  opRhs = vecPrintIns[i];
			  Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
        	   }           	   
	   	   Ob.LHS = std::make_pair(opLhs, indirLhs);	   	  
		}//end inner if			   
   	}//end outer if
        else if (originalName == "scanf") {  
		#if defined(TRACE) || defined(PRINT) 
		llvm::outs() << "\n Call to scanf";
		#endif
		Ob.setKill();
		indirLhs = 999; indirRhs = 1;
		std::vector<Token*> vecScanfIns = IM->extractToken(CI);
		if (vecScanfIns.size() > 1)	{ 
			callFlag = true;
		        for (int i = 1; i < vecScanfIns.size(); i++) {
				opRhs = vecScanfIns[i];
 			        Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
        		}           	   
		        Ob.LHS = std::make_pair(opLhs, indirLhs);	   	  
		}//end inner if			   
   	}//end outer if
	else {  
		fetchLR objFetchLR;
		#if defined(TRACE) || defined(PRINT) 
		llvm::outs() << "\n Instr is a call instruction.........";
		#endif
		Function* FunType = CI->getCalledFunction();

		insFlag = true; //Instr is considered and not skipped
		
		if (FunType == nullptr){
		  llvm::outs() << "\n Function call is an indirect call....";
		  funPtrFlag = true;
		  std::vector<Token*> vecCall = IM->extractToken(CI);
		  if (!vecCall.empty()) { 
			if (vecCall[0]->getName() != "NULL") { 
				//Lhs is available for call instr				
			}
			Token* opRhs = vecCall[1];
		        Ob.RHS.push_back(std::make_pair(opRhs, 1));
		        Ob.setCall();
			Ob.setInsFunPtr();
			callFlag = true;
			funPtrFlag = true;
			llvm::outs() << "\n Set the function pointer flag.";
			/* No argument mapping here since pointee of FP is unknown. */
                  }		
		}//end if indirect call		  
		else if (FunType && FunType->isVarArg()) {
		  llvm::outs() << "\n Function is a variadic function...";

                /* Following code for variadic functions is commented as on 19.5.22*/
		/*  Token* opRhs = TW.getToken(new spatial::Token(FunType));
		  Ob.RHS.push_back(std::make_pair(opRhs, 1));
		  Ob.setCall();
		  callFlag = true;
		  std::vector<Value*> caller, callee;
		  for (Value *ArgOperand : CI->args()) 
			caller.push_back(ArgOperand);
		  
		//  for (Value *ArgOperand : CI->getCalledFunction()->getArgOperand(0)) 
		//	callee.push_back(ArgOperand);
		for (auto arg = CI->getCalledFunction()->arg_begin(); arg != CI->getCalledFunction()->arg_end(); ++arg) {
			Value* V = dyn_cast<Value>(arg);
			llvm::outs() << "\n ARGUMENT: "<<V->getName();
			llvm::outs() << "\n ARGUMENT_1: "<<*arg;
// 			Value *ArgVal = CI->getCalledFunction()->getArgOperand(arg->getArgNo());		
//			llvm::outs() << "\n ARGUMENT_2: "<<ArgVal->getName();
	
		}
		  if (!ArgStore.empty())
			ArgStore.clear();*/
		
/*                  fetchLR newObjFetchLR, tempfetchLR;
		  auto i = 0;
		  for (Value *ArgOperand : CI->args()) {
		  //  llvm::outs() << "\n Args operand : "<<ArgOperand->getName();

		    if (ArgOperand->getType()->isPointerTy()) {
			llvm::outs() << "\n Call Inst Arg is of pointer type.";
			tempfetchLR = newObjFetchLR.getArgStore(CI->getCalledFunction()->getArg(i),ArgOperand);
			ArgStore.push_back(tempfetchLR);
		    	flagArgs = true;
                     }//end if
		     i++;	
                  }//end for
*/				
		/*	for(Function::arg_iterator argi=FunType->arg_begin(),arge=FunType->arg_end(); argi!=arge;argi++ )
            			llvm::outs()<< "\n Argument Variadic fun: "<<argi->getName();*/
		}//end else if
		else {
		     llvm::outs() << "\n Direct Function call...........";        
		     if (!FunType->isDeclaration()){
			fetchLR newObjFetchLR, tempfetchLR;
	        	std::vector<Token*> vecCall = IM->extractToken(CI);
			if (!vecCall.empty()) {
			 if (vecCall[0]->getName() != "NULL") {
			   if (vecCall[0]->isValPointerType()) {
			     #if defined(TRACE) || defined(PRINT) 
			     llvm::outs() << "\n LHS of the call instrutcion is a pointer.";
			     #endif
			     Token* lhsTemp = vecCall[0]; 
			     
			     std::vector<Token*> vecRhsTokens = mapReturnArg(FunType);

			     if (!ReturnArgStore.empty())
				ReturnArgStore.clear();
			    
			     if (vecRhsTokens.size() >= 1) {
				for (int i = 0; i < vecRhsTokens.size(); i++) { 
					Token* rhsTemp = vecRhsTokens[i]; 
					if (lhsTemp->getTy() == rhsTemp->getTy()) {
						#if defined(TRACE) || defined(PRINT) 
						llvm::outs() << "\n Types match";
						#endif
						tempfetchLR = newObjFetchLR.getRetArgStore(vecCall[0], rhsTemp);
						ReturnArgStore.push_back(tempfetchLR);
						flagRetArg = true;
					}
					else {
						llvm::outs() << "\n Type mismatch*************";			
						exit(-1);
					}
				}//end for	
			      }//end size>=1				  
			   }//end inner if pointer
			}//end outer if name not NULL
		        Token* opRhs = TW.getToken(new spatial::Token(FunType));
			Ob.RHS.push_back(std::make_pair(opRhs, 1));
			Ob.setCall();
			callFlag = true;
		
			if (!ArgStore.empty())
				ArgStore.clear();
			
			for(int i=0; i <CI->arg_size();i++) {
 			   fetchLR newObjFetchLR, tempfetchLR;
			   if (CI->getArgOperand(i)->getType()->isPointerTy()) {
				llvm::outs() << "\n Call Inst Arg is of pointer type.";
			        tempfetchLR = newObjFetchLR.getArgStore(CI->getCalledFunction()->getArg(i),CI->getArgOperand(i));
			        ArgStore.push_back(tempfetchLR);
		    	        flagArgs = true;
                           }//end if
		        }//end for
		 }//end if
            }//end if not declaration fun
         }//end else direct call
       }//end else call
   }
   return Ob;
}
//-------------------------------------------------------------------------------------------
fetchLR insReturn, insCompare, insPrintf; //global object

class Transform {
protected:
	std::map<long int, fetchLR> globalInstrIndexList;
	std::map<long int, Instruction*> mapInstWithIndx;
	std::map<std::pair<Function*, BasicBlock*>, std::list<long int>> funcBBInsMap;
	std::map<Instruction*, fetchLR> tempInstLR;
	std::map<std::pair<Function*, BasicBlock*>, std::list<Instruction*>> mapSkippedIns;
	std::map<std::pair<Function*, BasicBlock*>, std::list<Instruction*>> mapModeledIns;
	std::map<long int, Instruction*> mapIndirectFunCall;
	
public:	
	Transform() {
		 IM = new spatial::LFCPAInstModel(&TW);
	}
	void setLhsRhsMap(Function*, BasicBlock*); 
	void printGlobalInstrList();	
	void printfuncBBInsMap();
	void printmapSkippedIns();
	void printmapModeledIns();
	long int getFirstIns(Function*, BasicBlock*);
	long int getLastIns(Function*, BasicBlock*);
	std::list<long int> getReverseList(std::list<long int>);
	void checkReturnIns(Function*, BasicBlock*);
	void checkCompareIns(Function*, BasicBlock*);
	void simplifyIR(Function*, BasicBlock*);
	bool isBBInsLstEmpty(Function*, BasicBlock*);
	Instruction* getInstforIndx(long int);	
	BasicBlock* getBBfromFetchLR(fetchLR);
	Instruction* getIndirectCallIns(long int);	
};

Instruction* Transform::getIndirectCallIns(long int index) { return mapIndirectFunCall[index]; }

BasicBlock* Transform::getBBfromFetchLR(fetchLR Ob) {
	long int INDEX;
	for (auto g : globalInstrIndexList) {
		long int indx = g.first;
		fetchLR objLR = g.second;
		if (objLR == Ob) 
			INDEX = indx;		
	}

        for (auto map : funcBBInsMap) {
		std::pair<Function*, BasicBlock*> FB = map.first;
		std::list<long int> LIST = map.second;
		std::list<long int>::iterator itr;
		itr = std::find(LIST.begin(), LIST.end(), INDEX);
		if(itr != LIST.end())
		   return FB.second;
        }
}
 
//Returns the corresponding instruction for the global index
Instruction* Transform::getInstforIndx(long int Index) {
	return mapInstWithIndx[Index];
}
///Prints the instructions skipped by the abstraction
void Transform::printmapSkippedIns() {
	llvm::outs() << "\n Printing Skipped LLVM IR instructions......\n\n";
        for (auto itr : mapSkippedIns)	{
		Function * function;
		BasicBlock* basicBlock;
		std::tie(function, basicBlock) = itr.first;
		std::list<Instruction*> ins = itr.second;
		for (auto i : ins) {
			i->print(llvm::outs()); llvm::outs()<<"\n";
		}		
	}	
}

///Prints the instructions that are modeled by the abstraction
void Transform::printmapModeledIns() {
	llvm::outs() << "\n Printing Modeled LLVM IR instructions...........#\n";
        for (auto itr : mapModeledIns)	{
		Function * function;
		BasicBlock* basicBlock;
		std::tie(function, basicBlock) = itr.first;
		std::list<Instruction*> ins = itr.second;
		for (auto i : ins) {
			i->print(llvm::outs()); llvm::outs()<<"\n";
		}
	}	
}

void Transform::printfuncBBInsMap() {
#if defined(TRACE) || defined(PRINT) 
	llvm::outs() << "\n Printing funcBBInsMap......\n";
        for (auto itr : funcBBInsMap)	{
		Function * function;
		BasicBlock* basicBlock;
		std::tie(function, basicBlock) = itr.first;
		std::list<long int> ins = itr.second;
		llvm::outs()<<" \n Function: "<<function<<" BB: "<<basicBlock;
		llvm::outs()<< "\n Instr list: ";
		for (auto i : ins) {
			llvm::outs()<<i<<", ";
		}
	}		
#endif	
}

///Returns true if the basic block instruction list is empty
bool Transform::isBBInsLstEmpty(Function* F, BasicBlock* B)   {
    #if defined(TRACE) || defined(PRINT) 
    llvm::outs() << "\n Inside isBBInsLstEmpty....."; 
    #endif
    for (auto itr : funcBBInsMap)	{ 
	Function * function;
	BasicBlock* basicBlock;
	std::tie(function, basicBlock) = itr.first;
	std::list<long int> insList = itr.second;
	if (F == function and B == basicBlock) {
		if (insList.empty())
			return true;	
	}//end if
    }//end for
    return false;	
}

///Returns the first instruction ID in the basic block
long int Transform::getFirstIns(Function* F, BasicBlock* B)   {
    #if defined(TRACE) || defined(PRINT) 
    llvm::outs() << "\n Inside getfirstIns...............";
    #endif
    for (auto itr : funcBBInsMap)	{ 
	Function * function;
	BasicBlock* basicBlock;
	std::tie(function, basicBlock) = itr.first;
	std::list<long int> insList = itr.second;
	if (F == function and B == basicBlock)
		return insList.front();
    }
    return 0;   
}

///Returns the last instruction ID in the basic block
long int Transform::getLastIns(Function* F, BasicBlock* B)  {
  #if defined(TRACE) || defined(PRINT) 
  llvm::outs() << "\n Inside getLastIns.............";
  #endif
  for (auto itr : funcBBInsMap)  {
	Function * function;
	BasicBlock* basicBlock;
	std::tie(function, basicBlock) = itr.first;
	std::list<long int> insList = itr.second;
	long int indexTmp;
	if (F == function and B == basicBlock)
		return insList.back();
  }
  return 0; //if no instr in BB
}

///Returns the reversed instruction list 
std::list<long int> Transform::getReverseList(std::list<long int> inList)  {
	std::list<long int> revList;
	for (auto i : inList)
		revList.push_front(i);
       #ifdef PRINT
	llvm::outs()<<"\n Reverse List: ";
	for (auto r : revList)
		llvm::outs()<<r<<", ";
       #endif
	return revList;
}

///Simplifies the LLVM IR by abstracting the return, compare and call instructions
void Transform::simplifyIR(Function* F, BasicBlock* B) {
     #if defined(TRACE) || defined(PRINT) 
     llvm::outs() << "\n Inside SimplifyIR function ";
     #endif
     fetchLR objFetchLR;
     for (BasicBlock::iterator i=B->begin(), e=B->end(); i!=e; ++i)  {
        Instruction* ins = &(*i);
	if (isa<ReturnInst>(ins)) 	{
		#ifdef PRINT
  		llvm::outs() << "\n Instr is a RETURN.";
		ins->print(llvm::outs());
		#endif
		insReturn = objFetchLR.metaDataReturnIns(ins);
	   }//end return
	   else if (isa<ICmpInst>(ins)) 	{
		#ifdef PRINT
		llvm::outs() << "\n Instr is a Compare.";
		ins->print(llvm::outs());
		#endif
		insCompare = objFetchLR.metaDataCmpIns(ins);
		if (cmpFlag) { 
			tempInstLR[ins] = insCompare;
			cmpFlag = false;
		}
	   }//end compare	
	   else if (isa<CallInst>(ins)) {
		#if defined(TRACE) || defined(PRINT) 
		llvm::outs() << "\n Instr is a Call."; 
		ins->print(llvm::outs());			
		#endif
		
		if (!ArgStore.empty())
		   ArgStore.clear();
		
		insPrintf = objFetchLR.metaDataPrintfIns(ins);
				
		if (callFlag) {
			tempInstLR[ins] = insPrintf; 
			callFlag = false; //reset flag to handle other call instructions
		}
	   }   
	}//end for
}



///Abstracts all relevant instructions in LLVM IR
void Transform::setLhsRhsMap(Function* F, BasicBlock* B) {
  #if defined(TRACE) || defined(PRINT) 
  llvm::outs() << "\n Inside setLhsRhsMap.....";
  #endif
  fetchLR objFetchLR;
  #ifdef PRINT
  llvm::outs() << "\n Function name: "<<F<< "\t BB: "<<B;
  #endif
  globalCurrFun =  F;
  for (BasicBlock::iterator i=B->begin(), e=B->end(); i!=e; ++i) 	{
       	Instruction* ins = &(*i);
	#ifdef PRINT
	llvm::outs() << "\n Instruction: ";
	ins->print(llvm::outs());
	#endif
	llvm::outs()<<"\n";
	fetchLR objFetchLR;
	funcBBInsMap[std::make_pair(F, B)];
	
	if (isa<ReturnInst>(ins)) {
	    if (retFlag) {
		#ifdef PRINT
		llvm::outs() << "\n Return flag: "<<instrCounter;
	        llvm::outs() << "\n Function name: "<<F<< "\t BB: "<<B;
		#endif
	    	globalInstrIndexList[instrCounter] =  insReturn;  
 	    	funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		mapInstWithIndx[instrCounter] = ins;
	    	instrCounter++;
		mapModeledIns[std::make_pair(F, B)].push_back(ins);		
            }	
	}
	else if (isa<CmpInst>(ins)) {
	    if (tempInstLR.find(ins) != tempInstLR.end()) {
		#ifdef PRINT
		llvm::outs() << "\n CmpInst flag: "<<instrCounter;
		llvm::outs() << "\n Function name: "<<F<< "\t BB: "<<B;
		#endif
	    	fetchLR insCompare = tempInstLR[ins];
	    	globalInstrIndexList[instrCounter] =  insCompare;
 	    	funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		mapInstWithIndx[instrCounter] = ins;
		instrCounter++;	
		mapModeledIns[std::make_pair(F, B)].push_back(ins);		
	    }
	}
	else if (isa<CallInst>(ins)) {
		fetchLR insPrintf;
	    if (tempInstLR.find(ins) != tempInstLR.end()) { 
		#ifdef PRINT
		llvm::outs() << "\n CallInst flag: "<<instrCounter;
		llvm::outs() << "\n Function name: "<<F->getName()<< "\t BB: "<<B;
		#endif
		insPrintf = tempInstLR[ins];
		if(flagArgs) {  llvm::outs() << "\n Inside flagArgs.....";
		   for (std::list<fetchLR>::iterator i=ArgStore.begin(), e=ArgStore.end(); i!=e; ++i)  { 	
		   globalInstrIndexList[instrCounter] =  *i;  
                   funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		   instrCounter++;
		  }
		}
	        globalInstrIndexList[instrCounter] =  insPrintf;  
		funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		mapInstWithIndx[instrCounter] = ins;
		instrCounter++;
		mapModeledIns[std::make_pair(F, B)].push_back(ins);	
		if (funPtrFlag) {
			llvm::outs() << "\n Flag for function pointer is set. Entryinto the map";
			mapIndirectFunCall[instrCounter] = ins;
			funPtrFlag = false;//reset flag
		}

		if (flagRetArg) { llvm::outs() << "\n Inside flagRetArg............";
		  for (std::list<fetchLR>::iterator i=ReturnArgStore.begin(), e=ReturnArgStore.end(); i!=e; ++i)  {
			llvm::outs() << "\n Return value entered for index = "<< instrCounter;
		       globalInstrIndexList[instrCounter] =  *i;  
		       funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		       instrCounter++;
		  }//end for
		}
	    }//only if call instr is considered
	    else {
		//Call instr not considered
		mapSkippedIns[std::make_pair(F,B)].push_back(ins);
	    }
	}
	else if (!IM->isInstSkip(ins)) { 	// If Instruction is not skipped
	     #ifdef PRINT
	     llvm::outs() << "\n Instruction is not skipped.";
	     #endif
	     fetchLR tempInstOb = objFetchLR.metaDataSetter(ins);
	     
	     if (insFlag) {
		 #ifdef PRINT
		 llvm::outs() << "\n Not skipped flag: "<<instrCounter;
		 llvm::outs() << "\n Function name: "<<F<< "\t BB: "<<B;
		 #endif
	         globalInstrIndexList[instrCounter] =  tempInstOb;
 	         funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		 mapInstWithIndx[instrCounter] = ins;
	         instrCounter++;
		 mapModeledIns[std::make_pair(F, B)].push_back(ins);		
	     } 
	     else {
		 #ifdef PRINT
		 llvm::outs() <<"\n Instruction is skipped. ";
	 	 llvm::outs() << "\n Function name: "<<F<< "\t BB: "<<B;
		 #endif
		 mapSkippedIns[std::make_pair(F,B)].push_back(ins);
	     }
	}// end if
	else {
	     #ifdef PRINT
	     llvm::outs() <<"\n Instruction is not supported hence it is skipped. ";
 	     llvm::outs() << "\n Function name: "<<F<< "\t BB: "<<B;
	     #endif
	     mapSkippedIns[std::make_pair(F,B)].push_back(ins);
	}
  }//end for
  retFlag = false; //reset flag
}

///Prints instruction ID and corresponding instruction modeling
void Transform::printGlobalInstrList() {
  llvm::outs() << "\n Printing Global Instruction List.....#";
  for (auto i : globalInstrIndexList)	{
     llvm::outs() << "\n Index: " << i.first;
     fetchLR Obj = i.second;
     std::pair<Token*, int> Lhs = Obj.getLHS();
     std::vector<std::pair<Token*, int>> Rhs = Obj.getRHS();
		
     if (Lhs.first != NULL and !Obj.getUse() and !Obj.getKill()) {    
	  if (Obj.getFieldLhs() and Lhs.first->isValPointerType()) 
	        llvm::outs() << "\t Lhs: <" <<Lhs.first->getName() <<"->"<<objStruct.getStructFieldIndxLhs(i.first) <<", "<<Lhs.second<<" > \t" ;
	  else if (Obj.getFieldLhs() and !Lhs.first->isValPointerType())
		llvm::outs() << "\t Lhs: <" <<Lhs.first->getName() <<"."<<objStruct.getStructFieldIndxLhs(i.first) <<", "<<Lhs.second<<" > \t";
	  else	
	        llvm::outs() << "\t Lhs: <" <<Lhs.first->getName() <<", "<<Lhs.second<<" > \t\t";		
     }

      for (std::vector<std::pair<Token*, int>>::iterator r = Rhs.begin(); r!=Rhs.end(); r++) { 
        std::pair<Token*, int > rhsVal = *r;
        if (Obj.getPhi()) {  
	 std::vector<std::tuple<int, Token*, std::string,int>> vecPhiRhsOpd = objStruct.fetchPhiRhsOpd(i.first);
	 for (auto p = 0; p < vecPhiRhsOpd.size(); p++) {
	    std::tuple<int, Token*, std::string, int> phiRhs = vecPhiRhsOpd[p];
	    if (std::get<2>(phiRhs) != "") {
               if (std::get<1>(phiRhs)->isValPointerType())
    	 	llvm::outs() <<" Rhs: <"<< std::get<1>(phiRhs)->getName() <<"->"<<std::get<2>(phiRhs) <<", "<<std::get<3>(phiRhs)<<">";
               else 
    	 	llvm::outs() <<" Rhs: <"<< std::get<1>(phiRhs)->getName() <<"."<<std::get<2>(phiRhs) <<","<<std::get<3>(phiRhs)<<">";
	    }
	    else
		llvm::outs() <<" Rhs: <"<< std::get<1>(phiRhs)->getName()<<","<<std::get<3>(phiRhs)<<">";
	 }//end for
	 break;	
        }
        if (Lhs.second == 999/*Obj.getUse()*/) { 
	 Instruction *INST = getInstforIndx(i.first);  
	 std::vector<std::tuple<int, Token*, std::string,int>> vecIcmpRhsOpd = objStruct.fetchIcmpRhsOpd(INST);
	 for (auto p = 0; p < vecIcmpRhsOpd.size(); p++) { 
	    std::tuple<int, Token*, std::string, int> icmpRhs = vecIcmpRhsOpd[p];
	    if (std::get<2>(icmpRhs) != "") {
            if (std::get<1>(icmpRhs)->isValPointerType())
    	 	llvm::outs() <<" Rhs: <"<< std::get<1>(icmpRhs)->getName() <<"->"<<std::get<2>(icmpRhs) <<", "<<std::get<3>(icmpRhs)<<">";
            else 
    	 	llvm::outs() <<" Rhs: <"<< std::get<1>(icmpRhs)->getName() <<"."<<std::get<2>(icmpRhs) <<","<<std::get<3>(icmpRhs)<<">";
	    }
	    else
		llvm::outs() <<" Rhs: <"<< std::get<1>(icmpRhs)->getName()<<","<<std::get<3>(icmpRhs)<<">";
	  }
	  break;	
	}//end if 999


	if (Obj.getArgFieldRhs() and rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"->"<<rhsVal.first->getFieldIndex() << ", "<<rhsVal.second <<">"; 
	else if (Obj.getArgFieldRhs() and !rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"."<<rhsVal.first->getFieldIndex() << ", "<<rhsVal.second <<">";  
        else if (rhsVal.first->getIsRetGEP() and rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"->"<<rhsVal.first->getFieldIndex() << ", "<<rhsVal.second <<">"; 
	else if (rhsVal.first->getIsRetGEP() and !rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"."<<rhsVal.first->getFieldIndex() << ", "<<rhsVal.second <<">";    
        else if (Obj.getFieldRhs() and rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"->"<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else if (Obj.getFieldRhs() and !rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"."<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else if (Obj.getBitcast() and !rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"."<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else if (Obj.getBitcast() and rhsVal.first->isValPointerType()) 
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() <<"->"<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else
	   llvm::outs() <<" Rhs: <"<< rhsVal.first->getName() << ", "<<rhsVal.second <<">"; 	 
     }//end inner for
   }//end outer for
   llvm::outs() << "\n";			
}

