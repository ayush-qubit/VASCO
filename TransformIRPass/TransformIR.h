/*******************************************************************************************************
			"LLVM IR Transformation Pass"
Author:      Aditi Raste and Shreya Singh
Created on:  7 May 2021
Description: This code transforms LLVM IR generated by -instnamer and -mem2reg passes into a simplified form.
	     The pass performs the following taks:
	     1. Every IR instruction is translated into an assignment statement.
	     2. LHS and RHS are computed and stored from these translated assignment statements.
	     3. LHS and RHS are maintained along with their indirection levels.
             4. A Phi instruction is translated into a list of assignment statements and are executed in parallel.
	     5. Performs optimization on the IR that has the same effect of local copy propoagation and local dead code elimination.
Last Updated: 
Current Status: 
**********************************************************************************************************/

#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/Instructions.h"
#include <bits/stdc++.h>
#include <cxxabi.h>
#include "llvm/IR/Module.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/IR/InstrTypes.h"
#include "spatial/InstModel/LFCPAInstModel/LFCPAInstModel.h"
#include "spatial/InstInfo/InstInfo.h"
#include "spatial/Utils/CFGUtils.h"
#include "llvm/ADT/BitVector.h"
#include <string>

using namespace llvm;
using namespace spatial;

/*-- Global Definitions --*/
static long long int instrCounter = 1;
spatial::Token *TK;
spatial::TokenWrapper TW;
spatial:: LFCPAInstModel *IM;

class Array {
        std::map<std::pair<Token*, std::string>, bool> infoArrayMap;
public:
	void setArray(Token*, std::string);
	bool checkArray(Token*, std::string);	
	void printInfoArrayMap();
};

///Prints whether the Token is an Array
void Array::printInfoArrayMap() {
#if defined(TRACE) || defined(PRINT) 
	errs() << "\n Printing InfoArrayMap";
#endif
	for ( auto m : infoArrayMap) 
		std::pair<Token*, std::string> Op = m.first;
}

///Sets the array field in InfoArrayMap structure
void Array::setArray(Token* op, std::string fieldIndx) { 
		infoArrayMap[std::make_pair(op, fieldIndx)] = true;
}

///Checks if the Token is an Array
bool Array::checkArray(Token* op, std::string fieldIndx) { 
	for (auto arr : infoArrayMap) {
		if ((arr.first.first->getName() == op->getName()) and fieldIndx == arr.first.second)
			return true;
	}
	return false;
}
Array objArray;
//--------------------------------------------------------------------------------------------------

class Structure {
	std::map<long long int, std::string> structIndexLhs, structIndexRhs ;
	std::map<long long int, std::vector<std::tuple<int, Token*, std::string, int>>> insPhiRhsIndx;
	std::map<Instruction*, std::vector<std::tuple<int, Token*, std::string, int>>> insIcmpRhsIndx;
public:
	void setStructFieldIndxLhs(std::string);
	void setStructFieldIndxRhs(std::string);
        void setInsPhiRhsOpd(int, Token*, std::string,int);
	void setInsIcmpRhsOpd(Instruction*, int, Token*, std::string,int);  
	std::string getStructFieldIndxLhs(long long int);
	std::string getStructFieldIndxRhs(long long int);
	std::vector<std::tuple<int, Token*, std::string, int>> fetchPhiRhsOpd(long long int);
	std::vector<std::tuple<int, Token*, std::string, int>> fetchIcmpRhsOpd(Instruction*);
};

Structure objStruct;

void Structure::setStructFieldIndxLhs(std::string index) { structIndexLhs[instrCounter] = index; }

void Structure::setStructFieldIndxRhs(std::string index) { structIndexRhs[instrCounter] = index; }

/*Store index of GEP operand in Phi Instr*/
void Structure::setInsPhiRhsOpd(int B, Token *T, std::string index, int indir) {
	 insPhiRhsIndx[instrCounter].push_back(std::make_tuple(B,T,index,indir)); 
}

/*Store index of GEP operand in ICMP Instr*/
void Structure::setInsIcmpRhsOpd(Instruction* ins, int B, Token *T, std::string index, int indir) { 
	insIcmpRhsIndx[ins].push_back(std::make_tuple(B,T,index,indir)); 
}

std::string Structure::getStructFieldIndxLhs(long long int counter) { return structIndexLhs[counter]; }

std::string Structure::getStructFieldIndxRhs(long long int counter) { return structIndexRhs[counter]; }

std::vector<std::tuple<int, Token*, std::string,int>> Structure::fetchPhiRhsOpd(long long int counter) {
	return insPhiRhsIndx[counter];
}

std::vector<std::tuple<int, Token*, std::string,int>> Structure::fetchIcmpRhsOpd(Instruction* I) {
	return insIcmpRhsIndx[I];
}
//--------------------------------------------------------------------------------------------------------
enum InstTy { insUse, insKill, insCall, insPhi, insGEP, gopLhs, gopRhs, fieldLhs, fieldRhs, insBitcast, bitcastRhs, phiRhsIndx/*GEP in Phi*/ };
bool retFlag = false;  /* Set only if return stmt is considered */
bool insFlag = false;  /* Set only is instr is considered for analysis. Required for Skip instr */
bool callFlag = false; /* Set only if call instr is considered */
bool cmpFlag = false;  /* Set only if compare instr is considered */
std::set<Token*> arrOperand; /* Store array operands. Required to compute Pin_start */


class fetchLR {
protected:
 	std::pair<Token*, int > LHS;
        std::vector<std::pair<Token*, int >> RHS;
	BitVector InstTy;
	unsigned int Length;
public:
	fetchLR();
	void setUse();
	void setKill();
	void setPhi();
	void setGEP();
	void setGOPLhs();
	void setGOPRhs();
	void setCall();
	void setFieldLhs();
	void setFieldRhs();
        void setBitcast();
	void setBitcastRhs();
	void setPhiRhsIndx();
	bool getUse();
	bool getKill();
	bool getPhi();
	bool getGEP();
	bool getGOPLhs();
	bool getGOPRhs();
	bool getCall();
	bool getFieldLhs();
	bool getFieldRhs();
	bool getBitcast();
	bool getBitcastRhs();
	bool getPhiRhsIndx();
	fetchLR metaDataSetter(Instruction*);
	std::pair<Token*, int> getLHS();
	std::vector<std::pair<Token*, int>> getRHS();
	fetchLR metaDataReturnIns(Instruction*);
	fetchLR metaDataCmpIns(Instruction*);  
	fetchLR metaDataPrintfIns(Instruction*);
	std::string demangle(const char*);
	std::string getOriginalName(Function*);
	fetchLR getArgStore(Value* LHS, Value* RHS);
	void printOperands(fetchLR);
};

void fetchLR::printOperands(fetchLR Ob) {
  errs() << "\n Inside printOperands..........";
  std::pair<Token*, int> tempLHS;
  Token* lhsVal;
  int indirLhs;
  std::vector<std::pair<Token*, int>> rhsVector;
  std::set<std::pair<Token*, std::string>> OUTofInst, INofInst, INofInstPrev;
  std::string indxLHS;

  tempLHS = Ob.getLHS();
  lhsVal = tempLHS.first;  
  indirLhs = tempLHS.second;
  if (lhsVal != NULL)
	errs() << "\n Lhs: <"<<lhsVal->getName()<<", "<<indirLhs<<">";
  rhsVector = Ob.getRHS();
  for (std::vector<std::pair<Token*, int>>::iterator r = rhsVector.begin(); r!=rhsVector.end(); r++) {					
	std::pair<Token*, int > rhsVal = *r;
	errs() << "\n Rhs: <"<< rhsVal.first->getName() << ", "<<rhsVal.second <<">";
   }
}

fetchLR::fetchLR() {
  this->Length = 12;
  InstTy = llvm::BitVector(this->Length, false);
}

std::list<fetchLR> ArgStore; /* Mapped formal and actual arguments*/ 
bool flagArgs = false;

void fetchLR::setUse() { InstTy.set(insUse); }

void fetchLR::setKill() { InstTy.set(insKill); }

void fetchLR::setPhi() { InstTy.set(insPhi); }

void fetchLR::setGEP() { InstTy.set(insGEP); }

void fetchLR::setGOPLhs() { InstTy.set(gopLhs); }

void fetchLR::setGOPRhs() { InstTy.set(gopRhs); }

void fetchLR::setCall() { InstTy.set(insCall); }

void fetchLR::setFieldLhs() { InstTy.set(fieldLhs); }

void fetchLR::setFieldRhs() { InstTy.set(fieldRhs); }

void fetchLR::setBitcast() { InstTy.set(insBitcast); }

void fetchLR::setBitcastRhs() { InstTy.set(bitcastRhs); }

void fetchLR::setPhiRhsIndx() { InstTy.set(phiRhsIndx); }

bool fetchLR::getUse() { return InstTy.test(insUse); }

bool fetchLR::getKill() { return InstTy.test(insKill); }

bool fetchLR::getPhi() { return InstTy.test(insPhi); }

bool fetchLR::getGEP() { return InstTy.test(insGEP); }

bool fetchLR::getGOPLhs() { return InstTy.test(gopLhs); }

bool fetchLR::getGOPRhs() { return InstTy.test(gopRhs); }

bool fetchLR::getCall() { return InstTy.test(insCall); }

bool fetchLR::getFieldLhs() { return InstTy.test(fieldLhs); }

bool fetchLR::getFieldRhs() { return InstTy.test(fieldRhs); }

bool fetchLR::getBitcast() { return InstTy.test(insBitcast); }

bool fetchLR::getBitcastRhs() { return InstTy.test(bitcastRhs); }

bool fetchLR::getPhiRhsIndx() { return InstTy.test(phiRhsIndx); }

std::pair<Token*, int> fetchLR::getLHS() { return (this->LHS);}
	
std::vector<std::pair<Token*, int>> fetchLR::getRHS() {	return (this->RHS); }

///Computes the Tokens for LHS and RHS for an LLVM IR Instruction
fetchLR fetchLR::metaDataSetter(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
	errs() << "\n Inside function metaDataSetter";
#endif
	insFlag = false;
	RHS.clear();
	int indirLhs, indirRhs;

	if (StoreInst *SI = dyn_cast<StoreInst>(I)) {
	#if defined(TRACE) || defined(PRINT) 
	   errs() << "\n Instr is a STORE ";
	#endif
     	   std::vector<Token*> vecStoreIns = IM->extractToken(SI);

	   if (!vecStoreIns.empty()) {
		#ifdef PRINT
			errs() << "\n Store not empty";
		#endif
		insFlag = true; //Instr is considered and not skipped
		Token* opLhs = vecStoreIns[0];
		Token* opRhs = vecStoreIns[1];

		std::vector<int> vecIndir = IM->extractRedirections(I);
 		indirLhs = vecIndir[0]; indirRhs = vecIndir[1];

		if (!isa<Instruction>(SI->getPointerOperand())){
		    if (BitCastOperator* BO = dyn_cast<BitCastOperator>(SI->getPointerOperand())){
		        Token* DestTy = new Token(BO->getDestTy());
		        if (DestTy->isBasePointerType()){
                   	    Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
		            spatial::Token* LHSTok =  new spatial::Token(BCVar);
                	    LHSTok->setIndex(LHSTok, "[0]");
                	    LHSTok = TW.getToken(LHSTok);
                	    objStruct.setStructFieldIndxLhs(LHSTok->getFieldIndex());			
                	    this->setFieldLhs();
                	    opLhs = LHSTok;
			    opLhs->setIsOpBitcast(); //set the OpBitcast bit
		        }
		    }
		}
		if (!isa<Instruction>(SI->getOperand(0))){
			
			 if (BitCastOperator* BO = dyn_cast<BitCastOperator>(SI->getOperand(0))){
		        	Token* DestTy = new Token(BO->getDestTy());
		       		Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
                    		spatial::Token* RHSTok =  new spatial::Token(BCVar);
                    		RHSTok->setIndex(RHSTok, "[0]");
		                RHSTok = TW.getToken(RHSTok);
                    		objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
                    		this->setFieldRhs();
                    		opRhs = RHSTok;
		    		opRhs->setIsOpBitcast(); //set the OpBitcast bit
				this->setBitcastRhs();							
		        }
		}
		if (isa<GEPOperator>(SI->getOperand(0))) { /* First check if Lhs or Rhs is GEP Operator */
		#ifdef PRINT
		    errs() << "\n Rhs is GEP Operator ";
		#endif
		    this->setGOPRhs();
		    GEPOperator *GOP = dyn_cast<GEPOperator>(SI->getOperand(0));

 		    if (isa<GlobalVariable>(GOP->getOperand(0))) { /*Distinguishing between two kinds of GEP STORE instrs */
		    	this->setFieldRhs(); 
			if (GOP->getOperand(0)->getType()->getContainedType(0)->isArrayTy())
				indirRhs = 0;
			else    
				indirRhs = 1;
			#ifdef PRINT
			    	errs() <<"\n Name : "<< opRhs->getName() <<"  Field Index: "<< opRhs->getFieldIndex();
			#endif
		    	objStruct.setStructFieldIndxRhs(opRhs->getFieldIndex());
		    }
		}
		if (isa<GEPOperator>(SI->getOperand(1)) and opLhs->isGlobalVar()/*Addedin bchmk testing as indices were printed*/) {  
		#ifdef PRINT
		    errs() << " \n Lhs is GEP operator";
		#endif
		    this->setGOPLhs();
		    GEPOperator *GOP = dyn_cast<GEPOperator>(SI->getOperand(1));
		
		    /* SetArray if operand is Global and an array*/
		    if (IM->isArrayType(GOP) and  opLhs->isGlobalVar()) {
			#ifdef PRINT
				errs() << "\n Store to an array";	
			#endif
			opLhs->setIsArray();
			objArray.setArray(opLhs, opLhs->getFieldIndex());
		    }			
		    if (isa<GlobalVariable>(GOP->getOperand(0)) and isa<GEPOperator>(SI->getOperand(0))) {
			/* To handle the case s1.s2.f = &s1.s2.n*/
			this->setFieldLhs();
			indirLhs = 1;
			if (isa<GlobalVariable>(GOP->getOperand(1)))			
				indirRhs = 0;
		    	objStruct.setStructFieldIndxLhs(opLhs->getFieldIndex());
		    }
 		    if (isa<GlobalVariable>(GOP->getOperand(0))) { /*Distinguishing between two kinds of GEP STORE instrs */
		    	this->setFieldLhs();
			indirLhs = 1;
		    	objStruct.setStructFieldIndxLhs(opLhs->getFieldIndex());			
		    }
   	        }
	        RHS.push_back(std::make_pair(opRhs, indirRhs));
	        LHS = std::make_pair(opLhs, indirLhs);			
	   }//end empty vec
	}//end STORE
	else if (LoadInst *LI = dyn_cast<LoadInst>(I))	{
	#if defined(TRACE) || defined(PRINT) 
	    errs() << "\n Instr is a LOAD ";
	#endif
     	    std::vector<Token*> vecLoadIns = IM->extractToken(LI);
		
	    if (!vecLoadIns.empty()) {
		insFlag = true;	
		Token* opLhs = vecLoadIns[0]; 
		Token* opRhs = vecLoadIns[1];

		std::vector<int> vecIndir = IM->extractRedirections(I);
 		indirLhs = vecIndir[0]; indirRhs = vecIndir[1];

		if (!isa<Instruction>(LI->getPointerOperand())){
		    if (BitCastOperator* BO = dyn_cast<BitCastOperator>(LI->getPointerOperand())){
		        Token* DestTy = new Token(BO->getDestTy());
                int Memtype = -1;
                if (DestTy -> isValPointerType() && DestTy->getValue()->getType()->getNumContainedTypes() > 0)
                    Memtype = 0; // struct
                else if (DestTy -> isValPointerType() && DestTy->getValue()->getType()->getNumContainedTypes() == 0)
                    Memtype = 1; // var
                else if (DestTy -> isBasePointerType())
                    Memtype = 2; // array
		        if (Memtype != 1){
 	                	Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
	                	spatial::Token* RHSTok =  new spatial::Token(BCVar);
	                	RHSTok->setIndex(RHSTok, "[0]");
	                	RHSTok = TW.getToken(RHSTok);
	                	objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
	                	this->setFieldRhs();
	                	opRhs = RHSTok;
			        opRhs->setIsOpBitcast();
		        }
		    }
		}
		    
		if (isa<GEPOperator>(LI->getPointerOperand()) and opRhs->isGlobalVar()/*Added due to case in benchmarks*/) {
		/* First check if Rhs is GEP Operator */
		#ifdef PRINT
		    errs() << "\n Rhs is GEP Operator ";
		#endif
		    this->setGOPRhs();
		    GEPOperator *GOP = dyn_cast<GEPOperator>(LI->getPointerOperand());

 		    /*Check for Bitcast in GEP Load*/
		    if (true || isa<GlobalVariable>(GOP->getOperand(0))) {
		      if (BitCastOperator* BO = dyn_cast<BitCastOperator>(GOP->getOperand(0))) {
			#ifdef PRINT
				errs() << "\n GEP operand is a Bitcast";
			#endif
			std::string gopIndx = TK->getIndex(GOP); //store GEP operator index
			Token* DestTy = new Token(BO->getDestTy());
                	Token* BCVar = IM->getTokenWrapper()->getToken(BO->getOperand(0));
                    	spatial::Token* RHSTok =  new spatial::Token(BCVar);
                    	RHSTok->setIndex(RHSTok, "[0]"+ gopIndx); //RHSIndex = "[0]" + gopIndx;
                    	RHSTok = TW.getToken(RHSTok);
                    	objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
                    	this->setFieldRhs();
                    	opRhs = RHSTok;  	
		     }//end if
		    }//end outer if
		   /* SetArray if operand is Global and an array*/
		    if (IM->isArrayType(GOP) and  opRhs->isGlobalVar()) {
			#ifdef PRINT
				errs() << "\n Load from an array";
			#endif	
			opRhs->setIsArray();
			objArray.setArray(opRhs, opRhs->getFieldIndex());
		    }
		    if (isa<GlobalVariable>(GOP->getOperand(0))) { /*Distinguishing between two kinds of GEP LOAD instrs */
			this->setFieldRhs(); 
		    	indirRhs = 1;
		    	objStruct.setStructFieldIndxRhs(opRhs->getFieldIndex());
		    }
		}
	        RHS.push_back(std::make_pair(opRhs, indirRhs));
	        LHS = std::make_pair(opLhs, indirLhs);			
	  }//end empty vec
	}//end LOAD
	else if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {
		#if defined(TRACE) || defined(PRINT) 
			errs() << "\n Instr is a GEP  ";
		#endif
		this->setFieldRhs();
		std::vector<Token*> vecGEPIns = IM->extractToken(GEP);
	
		if (!vecGEPIns.empty()) { 
			insFlag = true;
			this->setGEP();
			Token* opLhs = vecGEPIns[0];
			Token* opRhs = vecGEPIns[1];
			std::vector<int> vecIndir = IM->extractRedirections(I);
 			indirLhs = vecIndir[0]; indirRhs = vecIndir[1];
			LHS = std::make_pair(opLhs, indirLhs);
			objStruct.setStructFieldIndxRhs(opRhs->getFieldIndex());	
			Value* Op = GEP->getOperand(0);
			/* check if GEP operand is an array type(local decl)*/		
		        if (!isa<Instruction>(Op)) {  
                		if (BitCastOperator* BCO = dyn_cast<BitCastOperator>(Op)){
				  #if defined(TRACE) || defined(PRINT) 
				  errs() << "\n Bitcast instr in a GEP.";
				  #endif
               		          Op = BCO->getOperand(0);
				          	        
                	        if (Op->getType()->getContainedType(0)->isArrayTy()){
				  #if defined(TRACE) || defined(PRINT) 
			          errs() << "\n Bitcast in a GEP is an array type. ";
		                  #endif
                	          opRhs = TW.getToken(new spatial::Token(Op));
				  opRhs->setIndex(opRhs);
                	        }
				else {
				  #if defined(TRACE) || defined(PRINT) 
			          errs() << "\n Bitcast in a GEP is not an array type. ";
		                  #endif
				  opRhs = TW.getToken(new spatial::Token(Op));
				  opRhs->setIndex(opRhs);
				}
			    }
                        }
			if (Op->getType()->getContainedType(0)->isArrayTy()) {
				opRhs->setIsArray();
				objArray.setArray(opRhs, opRhs->getFieldIndex());
			}	
			if (GEP->getNumOperands() == 2) {
				  #if defined(TRACE) || defined(PRINT) 
			          errs() << "\n GEP instruction operand has only one index. ";
		                  #endif
				 opRhs->setIsOneGEPIndx();
			}		       
			RHS.push_back(std::make_pair(opRhs, indirRhs));
		}
	}//end GEP
	else if (BitCastInst *BI = dyn_cast<BitCastInst>(I)) {
		#if defined(TRACE) || defined(PRINT) 
			errs() << "\n Instr is Bitcast Instruction ";
		#endif
        // x = bitcast y
        // x = y[0]
		Token* DestTy = new Token(BI->getDestTy());
		std::vector<Token*> VecBitCastInstToken = IM->extractToken(BI);
		std::vector<int> VecBitCastInstIndir = IM->extractRedirections(I);
		this->setBitcast();
		
		if (!VecBitCastInstToken.empty()) {
		   	insFlag = true;
			LHS = std::make_pair(VecBitCastInstToken[0], VecBitCastInstIndir[0]);
        		spatial::Token* RHSTok =  new spatial::Token(VecBitCastInstToken[1]);
	                RHSTok->setIndex(RHSTok, "[0]");
			RHSTok = TW.getToken(RHSTok);
			if (VecBitCastInstToken[1]->getIsAlloca())
				RHSTok->setIsAlloca();
			RHS.push_back(std::make_pair(RHSTok, VecBitCastInstIndir[1]));
			objStruct.setStructFieldIndxRhs(RHSTok->getFieldIndex());			
		}
	}
	else if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {
 		#if defined(TRACE) || defined(PRINT) 
			errs() << "\n Inst is an ALLOCA Inst. ";
		#endif
		std::vector<Token*> vecAIIns = IM->extractToken(AI);
        }//end alloca
	else if (PHINode *PHI = dyn_cast<PHINode>(I)) {
		#if defined(TRACE) || defined(PRINT) 
			errs() << "\n Inst is Phi Instruction";
		#endif
		std::vector<Token*> vecPHIIns = IM->extractToken(PHI);
		
		if (vecPHIIns.size() > 1)	{ 
		   this->setPhi();
		   insFlag = true;
	 	   std::vector<int> vecIndir = IM->extractRedirections(I);
 		   indirLhs = vecIndir[0]; 
		   Token* opLhs = vecPHIIns[0];  

		   LHS = std::make_pair(opLhs, indirLhs);

        	   for (int i = 1; i < vecPHIIns.size(); i++) { 
	  	      Token *opRhs = vecPHIIns[i];	
		      if (opRhs->getName() != "NULL") {
		        if (!isa<Instruction>(I->getOperand(i-1))) {  
			// operands of phi could be GEP or BITCAST operators
		           if (isa<BitCastOperator>(I->getOperand(i-1))){   //Phi operand is bitcast operator
				#if defined(TRACE) || defined(PRINT) 
			          errs() << "\n Bitcast in a PHI Instr. ";
		                #endif
				BitCastOperator* BCO = dyn_cast<BitCastOperator>(I->getOperand(i-1));
			
				if (isa<GEPOperator>(BCO->getOperand(0)))  {
				  #if defined(TRACE) || defined(PRINT) 
				    errs() << "\n GEP within a Bitcast in a PHI Instr. ";
		                  #endif
				   GEPOperator *GEPOp = dyn_cast<GEPOperator>(BCO->getOperand(0));
				   std::string opIndx = TK->getIndex(GEPOp);	
				   opRhs = TW.getToken(new spatial::Token(GEPOp->getOperand(0)));
				   opRhs->setIndex(GEPOp);
				   indirRhs = 0;
				   objStruct.setInsPhiRhsOpd((i-1),opRhs, opRhs->getFieldIndex(),indirRhs);
				   RHS.push_back(std::make_pair(opRhs, indirRhs));
				}  
				else {
				   #if defined(TRACE) || defined(PRINT) 
				    errs() << "\n Normal Bitcast in a PHI Instr. ";
		                   #endif
				    opRhs = TW.getToken(new spatial::Token(BCO->getOperand(0)));
				    opRhs->setIndex(opRhs, "[0]");
				    indirRhs = 1;
				    objStruct.setInsPhiRhsOpd((i-1),opRhs, opRhs->getFieldIndex(),indirRhs);
				    RHS.push_back(std::make_pair(opRhs, indirRhs));
				}
			}
			else if (isa<GEPOperator>(I->getOperand(i-1))) { //Phi operand is GEP operator
				  #if defined(TRACE) || defined(PRINT) 
					errs() << "\n PHI operand_"<<i<<" is a GEP Operator";
		                  #endif
	
				if (!isa<Instruction>(I->getOperand(i-1))) {
					this->setPhiRhsIndx();
					opRhs->setIsPhiGEPOpd();
					indirRhs = 0;
					objStruct.setInsPhiRhsOpd((i-1),opRhs, opRhs->getFieldIndex(),indirRhs);
			  		RHS.push_back(std::make_pair(opRhs, indirRhs));					
				}
			        else {
					indirRhs = 1;
					objStruct.setInsPhiRhsOpd((i-1),opRhs,"",indirRhs);
			  		RHS.push_back(std::make_pair(opRhs, indirRhs));					
				}//end else non-gep							
			}
			else {
				#if defined(TRACE) || defined(PRINT) 
					errs() << "\n PHI Operand is an formal/input parameter. ";
		                #endif
				if (opRhs->isGlobalVar())
					indirRhs = 0;
				else
					indirRhs = 1;
				objStruct.setInsPhiRhsOpd((i-1),opRhs,"",indirRhs);
				RHS.push_back(std::make_pair(opRhs, indirRhs));
			}
		     }//end if instr
		     else {
				#if defined(TRACE) || defined(PRINT) 
					errs() << "\n Normal PHI Instruction. ";
		                #endif

				if (opRhs->isGlobalVar())
					indirRhs = 0;
				else
					indirRhs = 1;
				objStruct.setInsPhiRhsOpd((i-1),opRhs,"",indirRhs);
		  		RHS.push_back(std::make_pair(opRhs, indirRhs));
		     }//end else normal opd	
		   }//end if name not null		
        	  }//end for
		}//end if
	}//end phi
	return *this;
}	

 inline std::string fetchLR::demangle(const char* name)   {
        int status = -1;

        std::unique_ptr<char, void(*)(void*)> res { abi::__cxa_demangle(name, NULL, NULL, &status), std::free };
        return (status == 0) ? res.get() : std::string(name);
 }

 std::string fetchLR::getOriginalName(Function* calledFunction)  {
	std::string emptyString;
	if (calledFunction != nullptr) { 
	        std::string s1 = demangle(calledFunction->getName().str().c_str());
        	size_t found = s1.find('<');
        	size_t found1 = s1.find(' ');
        	if (found!=std::string::npos and found1!=std::string::npos)
        	    s1 = std::string(s1.begin()+found1+1, s1.begin()+found);
        	return s1;
	}
	return emptyString;
 }

///Computes the RHS Tokens for Compare Instruction in LLVM IR
fetchLR fetchLR::metaDataCmpIns(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
  errs() << "\n Inside metaDataCmpIns....";
#endif
  int indirLhs, indirRhs;
  fetchLR Ob;
  
  if (CmpInst *CM = dyn_cast<CmpInst>(I)) {
   #ifdef PRINT
    errs() << "\n Instr is a compare";
   #endif

    std::vector<Token*> vecCmpIns = IM->extractToken(CM); 
    indirLhs = 999; indirRhs = 1;
    Token *opRhs, *opLhs;
    Ob.setUse();

    if (!vecCmpIns.empty())	{ 
	cmpFlag = true;
        for (int i = 0; i < vecCmpIns.size(); i++) {
	  opRhs = vecCmpIns[i];

	  if (!isa<Instruction>(I->getOperand(i))) {
		if (isa<GEPOperator>(I->getOperand(i))) {
			#if defined(TRACE) || defined(PRINT) 
			errs() << "\n Compare Operand is a GEP. ";
		        #endif
			GEPOperator *GEPOp = dyn_cast<GEPOperator>(I->getOperand(i));
			std::string opIndx = TK->getIndex(GEPOp);	
			opRhs = TW.getToken(new spatial::Token(GEPOp->getOperand(0)));
			opRhs->setIndex(GEPOp);
			opRhs->setIsIcmpGEPOpd();
			indirRhs = 0;
			objStruct.setInsIcmpRhsOpd(I,i,opRhs, opRhs->getFieldIndex(),indirRhs);
		  	Ob.RHS.push_back(std::make_pair(opRhs, indirRhs)); 
		}
		else {
			#if defined(TRACE) || defined(PRINT) 
			errs() << "\n Non-GEP Compare Operand. ";
	                #endif
			objStruct.setInsIcmpRhsOpd(I,i,opRhs, opRhs->getFieldIndex(),indirRhs);
			Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
		}
	  }
	  else {
		#if defined(TRACE) || defined(PRINT) 
		errs() << "\n Normal Compare OPerand. ";
                #endif
		objStruct.setInsIcmpRhsOpd(I,i,opRhs, opRhs->getFieldIndex(),indirRhs);
		Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
	  }
        }
        Ob.LHS = std::make_pair(opLhs, indirLhs);
    }//end inner if
   }//end outer if
   return Ob;	
}

///Computes the RHS Tokens for Return Instruction in LLVM IR
fetchLR fetchLR::metaDataReturnIns(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
  errs() << "\n Inside metaDataReturnIns....";
#endif
  int indirLhs, indirRhs;
  fetchLR Ob;
  if (ReturnInst *RI = dyn_cast<ReturnInst>(I))   {
	#ifdef PRINT
	errs() << "\n Instr is a RETURN ";
	#endif
	std::vector<Token*> vecRetIns = IM->extractToken(RI); 
	Token* opLhs, *opRhs;
	Ob.setUse();

	if (!vecRetIns.empty())	{
	   retFlag = true;
           opRhs = vecRetIns[0];
	   indirLhs = 99; indirRhs = 1;
	   Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
	   Ob.LHS = std::make_pair(opLhs, indirLhs);
	   return Ob;
	}			   
   }//end outer if
   return Ob;
}// end RETURN

fetchLR fetchLR::getArgStore(Value* LHS, Value* RHS) {
#if defined(TRACE) || defined(PRINT) 
  errs() << "\n Inside getArgStore....";
#endif
  fetchLR Ob;
  spatial::Token* RHSTok = TW.getToken(new Token(RHS));
  Ob.RHS.push_back(std::make_pair(RHSTok, 1));
  Ob.LHS = std::make_pair(TW.getToken(new Token(LHS)), 1);	   	  
  return Ob;
}


///Computes the RHS Tokens for Printf/Scanf Call Instructions in LLVM IR
fetchLR fetchLR::metaDataPrintfIns(Instruction* I) {
#if defined(TRACE) || defined(PRINT) 
  errs() << "\n Inside metaDataPrintfIns....";
#endif
  int indirLhs, indirRhs;
  fetchLR Ob;
  Token* opLhs, *opRhs;

  if (CallInst *CI = dyn_cast<CallInst>(I)) {  
	Function* calledFunction = cast<CallInst>(CI)->getCalledFunction();        
        std::string originalName = getOriginalName(calledFunction);
	if (originalName == "printf") {  
		#if defined(TRACE) || defined(PRINT) 
		errs() << "\n Call to printf";
		#endif
		Ob.setUse();
		indirLhs = 999; indirRhs = 1;
		std::vector<Token*> vecPrintIns = IM->extractToken(CI);
		if (vecPrintIns.size() > 1) {
		   callFlag = true;
	           for (int i = 1; i < vecPrintIns.size(); i++) {
			  opRhs = vecPrintIns[i];
			  Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
        	   }           	   
	   	   Ob.LHS = std::make_pair(opLhs, indirLhs);	   	  
		}//end inner if			   
   	}//end outer if
        else if (originalName == "scanf") {  
		#if defined(TRACE) || defined(PRINT) 
		errs() << "\n Call to scanf";
		#endif
		Ob.setKill();
		indirLhs = 999; indirRhs = 1;
		std::vector<Token*> vecScanfIns = IM->extractToken(CI);
		if (vecScanfIns.size() > 1)	{ 
			callFlag = true;
		        for (int i = 1; i < vecScanfIns.size(); i++) {
				opRhs = vecScanfIns[i];
 			        Ob.RHS.push_back(std::make_pair(opRhs, indirRhs));
        		}           	   
		        Ob.LHS = std::make_pair(opLhs, indirLhs);	   	  
		}//end inner if			   
   	}//end outer if
	else {  
		fetchLR objFetchLR;
		//#if defined(TRACE) || defined(PRINT) 
		errs() << "\n Instr is a call instruction.........";
		//#endif
		Function* FunType = CI->getCalledFunction();
		insFlag = true; //Instr is considered and not skipped
               
	        std::vector<Token*> vecCall = IM->extractToken(CI);
		if (!vecCall.empty()) {
			if (vecCall[0]->getName() != "NULL")
		        	Ob.LHS = std::make_pair(vecCall[0], 1);
		        Token* opRhs = TW.getToken(new spatial::Token(FunType));
			Ob.RHS.push_back(std::make_pair(opRhs, 1));
			Ob.setCall();
			callFlag = true;
			
			for(int i=0; i <CI->arg_size();i++) {
 			   fetchLR newObjFetchLR, tempfetchLR;
         	           if (!isa<Instruction>(CI->getArgOperand(i)))
                        	continue;
                    	    tempfetchLR = newObjFetchLR.getArgStore(CI->getCalledFunction()->getArg(i),CI->getArgOperand(i));
			    ArgStore.push_back(tempfetchLR);
		    	    flagArgs = true;
		         }
/*		    errs() << "\n Printing the arguments of function call....................";
		    errs() << "\n Argstore lhs= "<<(ArgStore.getLHS()).first->getName();
		    errs() << "\n Argstore lhs= "<<((ArgStore.getRHS())[0]).first->getName();
		    errs() << "\n Instruction counter = "<< instrCounter;	*/
		 }//end if
	   }//end else call
   }
   return Ob;
}
//-------------------------------------------------------------------------------------------
fetchLR insReturn, insCompare, insPrintf; //global object

class Transform {
protected:
	std::map<long int, fetchLR> globalInstrIndexList;
	std::map<long int, Instruction*> mapInstWithIndx;
	std::map<std::pair<Function*, BasicBlock*>, std::list<long int>> funcBBInsMap;
	std::map<Instruction*, fetchLR> tempInstLR;
	std::map<std::pair<Function*, BasicBlock*>, std::list<Instruction*>> mapSkippedIns;
	std::map<std::pair<Function*, BasicBlock*>, std::list<Instruction*>> mapModeledIns;
public:	
	Transform() {
		 IM = new spatial::LFCPAInstModel(&TW);
	}
	void setLhsRhsMap(Function*, BasicBlock*); 
	void printGlobalInstrList();	
	void printfuncBBInsMap();
	void printmapSkippedIns();
	void printmapModeledIns();
	long int getFirstIns(Function*, BasicBlock*);
	long int getLastIns(Function*, BasicBlock*);
	std::list<long int> getReverseList(std::list<long int>);
	void checkReturnIns(Function*, BasicBlock*);
	void checkCompareIns(Function*, BasicBlock*);
	void simplifyIR(Function*, BasicBlock*);
	bool isBBInsLstEmpty(Function*, BasicBlock*);
	Instruction* getInstforIndx(long int);
};


//Returns the corresponding instruction for the global index
Instruction* Transform::getInstforIndx(long int Index) {
	return mapInstWithIndx[Index];
}
///Prints the instructions skipped by the abstraction
void Transform::printmapSkippedIns() {
	errs() << "\n Printing Skipped LLVM IR instructions......\n\n";
        for (auto itr : mapSkippedIns)	{
		Function * function;
		BasicBlock* basicBlock;
		std::tie(function, basicBlock) = itr.first;
		std::list<Instruction*> ins = itr.second;
		for (auto i : ins) {
			i->print(errs()); errs()<<"\n";
		}		
	}	
}

///Prints the instructions that are modeled by the abstraction
void Transform::printmapModeledIns() {
	errs() << "\n Printing Modeled LLVM IR instructions...........#\n";
        for (auto itr : mapModeledIns)	{
		Function * function;
		BasicBlock* basicBlock;
		std::tie(function, basicBlock) = itr.first;
		std::list<Instruction*> ins = itr.second;
		for (auto i : ins) {
			i->print(errs()); errs()<<"\n";
		}
	}	
}

void Transform::printfuncBBInsMap() {
#if defined(TRACE) || defined(PRINT) 
	errs() << "\n Printing funcBBInsMap......\n";
        for (auto itr : funcBBInsMap)	{
		Function * function;
		BasicBlock* basicBlock;
		std::tie(function, basicBlock) = itr.first;
		std::list<long int> ins = itr.second;
		errs()<<" \n Function: "<<function<<" BB: "<<basicBlock;
		errs()<< "\n Instr list: ";
		for (auto i : ins) {
			errs()<<i<<", ";
		}
	}		
#endif	
}

///Returns true if the basic block instruction list is empty
bool Transform::isBBInsLstEmpty(Function* F, BasicBlock* B)   {
    #if defined(TRACE) || defined(PRINT) 
    errs() << "\n Inside isBBInsLstEmpty....."; 
    #endif
    for (auto itr : funcBBInsMap)	{ 
	Function * function;
	BasicBlock* basicBlock;
	std::tie(function, basicBlock) = itr.first;
	std::list<long int> insList = itr.second;
	if (F == function and B == basicBlock) {
		if (insList.empty())
			return true;	
	}//end if
    }//end for
    return false;	
}

///Returns the first instruction ID in the basic block
long int Transform::getFirstIns(Function* F, BasicBlock* B)   {
    #if defined(TRACE) || defined(PRINT) 
    errs() << "\n Inside getfirstIns...............";
    #endif
    for (auto itr : funcBBInsMap)	{ 
	Function * function;
	BasicBlock* basicBlock;
	std::tie(function, basicBlock) = itr.first;
	std::list<long int> insList = itr.second;
	if (F == function and B == basicBlock)
		return insList.front();
    }
    return 0;   
}

///Returns the last instruction ID in the basic block
long int Transform::getLastIns(Function* F, BasicBlock* B)  {
  #if defined(TRACE) || defined(PRINT) 
  errs() << "\n Inside getLastIns.............";
  #endif
  for (auto itr : funcBBInsMap)  {
	Function * function;
	BasicBlock* basicBlock;
	std::tie(function, basicBlock) = itr.first;
	std::list<long int> insList = itr.second;
	long int indexTmp;
	if (F == function and B == basicBlock)
		return insList.back();
  }
  return 0; //if no instr in BB
}

///Returns the reversed instruction list 
std::list<long int> Transform::getReverseList(std::list<long int> inList)  {
	std::list<long int> revList;
	for (auto i : inList)
		revList.push_front(i);
       #ifdef PRINT
	errs()<<"\n Reverse List: ";
	for (auto r : revList)
		errs()<<r<<", ";
       #endif
	return revList;
}

///Simplifies the LLVM IR by abstracting the return, compare and call instructions
void Transform::simplifyIR(Function* F, BasicBlock* B) {
     #if defined(TRACE) || defined(PRINT) 
     errs() << "\n Inside SimplifyIR function ";
     #endif
     fetchLR objFetchLR;
     for (BasicBlock::iterator i=B->begin(), e=B->end(); i!=e; ++i)  {
        Instruction* ins = &(*i);
	if (isa<ReturnInst>(ins)) 	{
		#ifdef PRINT
  		errs() << "\n Instr is a RETURN.";
		ins->print(errs());
		#endif
		insReturn = objFetchLR.metaDataReturnIns(ins);
	   }//end return
	   else if (isa<ICmpInst>(ins)) 	{
		#ifdef PRINT
		errs() << "\n Instr is a Compare.";
		ins->print(errs());
		#endif
		insCompare = objFetchLR.metaDataCmpIns(ins);
		if (cmpFlag) { 
			tempInstLR[ins] = insCompare;
			cmpFlag = false;
		}
	   }//end compare	
	   else if (isa<CallInst>(ins)) {
		#if defined(TRACE) || defined(PRINT) 
		errs() << "\n Instr is a Call.";
		ins->print(errs());
		#endif
		
		insPrintf = objFetchLR.metaDataPrintfIns(ins);
		errs()<<"\n callFLag= "<<callFlag;
		if (callFlag) {
			tempInstLR[ins] = insPrintf; 
			callFlag = false; //reset flag to handle other call instructions
		}
	   }   
	}//end for
}

///Abstracts all relevant instructions in LLVM IR
void Transform::setLhsRhsMap(Function* F, BasicBlock* B) {
  #if defined(TRACE) || defined(PRINT) 
  errs() << "\n Inside setLhsRhsMap.....";
  #endif
  fetchLR objFetchLR;
  #ifdef PRINT
  errs() << "\n Function name: "<<F<< "\t BB: "<<B;
  #endif
  for (BasicBlock::iterator i=B->begin(), e=B->end(); i!=e; ++i) 	{
       	Instruction* ins = &(*i);
	#ifdef PRINT
	errs() << "\n Instruction: ";
	ins->print(errs());
	#endif
	errs()<<"\n";
	fetchLR objFetchLR;
	funcBBInsMap[std::make_pair(F, B)];
	
	if (isa<ReturnInst>(ins)) {
	    if (retFlag) {
		#ifdef PRINT
		errs() << "\n Return flag: "<<instrCounter;
	        errs() << "\n Function name: "<<F<< "\t BB: "<<B;
		#endif
	    	globalInstrIndexList[instrCounter] =  insReturn;  
 	    	funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		mapInstWithIndx[instrCounter] = ins;
	    	instrCounter++;
		mapModeledIns[std::make_pair(F, B)].push_back(ins);		
            }	
	}
	else if (isa<CmpInst>(ins)) {
	    if (tempInstLR.find(ins) != tempInstLR.end()) {
		#ifdef PRINT
		errs() << "\n CmpInst flag: "<<instrCounter;
		errs() << "\n Function name: "<<F<< "\t BB: "<<B;
		#endif
	    	fetchLR insCompare = tempInstLR[ins];
	    	globalInstrIndexList[instrCounter] =  insCompare;
 	    	funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		mapInstWithIndx[instrCounter] = ins;
		instrCounter++;	
		mapModeledIns[std::make_pair(F, B)].push_back(ins);		
	    }
	}
	else if (isa<CallInst>(ins)) {
	    if (tempInstLR.find(ins) != tempInstLR.end()) { 
		#ifdef PRINT
		errs() << "\n CallInst flag: "<<instrCounter;
		errs() << "\n Function name: "<<F<< "\t BB: "<<B;
		#endif
		fetchLR insPrintf = tempInstLR[ins];
		if(flagArgs) {
		   for (std::list<fetchLR>::iterator i=ArgStore.begin(), e=ArgStore.end(); i!=e; ++i)  {
		   globalInstrIndexList[instrCounter] =  *i;  
                   funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		   instrCounter++;
		  }
		}
	        globalInstrIndexList[instrCounter] =  insPrintf;  
		funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		mapInstWithIndx[instrCounter] = ins;
		instrCounter++;
		mapModeledIns[std::make_pair(F, B)].push_back(ins);		
	    }//only if call instr is considered
	    else {
		//Call instr not considered
		mapSkippedIns[std::make_pair(F,B)].push_back(ins);
	    }
	}
	else if (!IM->isInstSkip(ins)) { 	// If Instruction is not skipped
	     #ifdef PRINT
	     errs() << "\n Instruction is not skipped.";
	     #endif
	     fetchLR tempInstOb = objFetchLR.metaDataSetter(ins);
	     
	     if (insFlag) {
		 #ifdef PRINT
		 errs() << "\n Not skipped flag: "<<instrCounter;
		 errs() << "\n Function name: "<<F<< "\t BB: "<<B;
		 #endif
	         globalInstrIndexList[instrCounter] =  tempInstOb;
 	         funcBBInsMap[std::make_pair(F, B)].push_back(instrCounter);
		 mapInstWithIndx[instrCounter] = ins;
	         instrCounter++;
		 mapModeledIns[std::make_pair(F, B)].push_back(ins);		
	     } 
	     else {
		 #ifdef PRINT
		 errs() <<"\n Instruction is skipped. ";
	 	 errs() << "\n Function name: "<<F<< "\t BB: "<<B;
		 #endif
		 mapSkippedIns[std::make_pair(F,B)].push_back(ins);
	     }
	}// end if
	else {
	     #ifdef PRINT
	     errs() <<"\n Instruction is not supported hence it is skipped. ";
 	     errs() << "\n Function name: "<<F<< "\t BB: "<<B;
	     #endif
	     mapSkippedIns[std::make_pair(F,B)].push_back(ins);
	}
  }//end for
  retFlag = false; //reset flag
}

///Prints instruction ID and corresponding instruction modeling
void Transform::printGlobalInstrList() {
  errs() << "\n Printing Global Instruction List.....#";
  for (auto i : globalInstrIndexList)	{
     errs() << "\n Index: " << i.first;
     fetchLR Obj = i.second;
     std::pair<Token*, int> Lhs = Obj.getLHS();
     std::vector<std::pair<Token*, int>> Rhs = Obj.getRHS();
		
     if (Lhs.first != NULL and !Obj.getUse() and !Obj.getKill()) {   
	  if (Obj.getFieldLhs() and Lhs.first->isValPointerType()) 
	        errs() << "\t Lhs: <" <<Lhs.first->getName() <<"->"<<objStruct.getStructFieldIndxLhs(i.first) <<", "<<Lhs.second<<" > \t" ;
	  else if (Obj.getFieldLhs() and !Lhs.first->isValPointerType())
		errs() << "\t Lhs: <" <<Lhs.first->getName() <<"."<<objStruct.getStructFieldIndxLhs(i.first) <<", "<<Lhs.second<<" > \t";
	  else	
	        errs() << "\t Lhs: <" <<Lhs.first->getName() <<", "<<Lhs.second<<" > \t\t";		
     }

      for (std::vector<std::pair<Token*, int>>::iterator r = Rhs.begin(); r!=Rhs.end(); r++) { 
        std::pair<Token*, int > rhsVal = *r;
        if (Obj.getPhi()) {  
	 std::vector<std::tuple<int, Token*, std::string,int>> vecPhiRhsOpd = objStruct.fetchPhiRhsOpd(i.first);
	 for (auto p = 0; p < vecPhiRhsOpd.size(); p++) {
	    std::tuple<int, Token*, std::string, int> phiRhs = vecPhiRhsOpd[p];
	    if (std::get<2>(phiRhs) != "") {
               if (std::get<1>(phiRhs)->isValPointerType())
    	 	errs() <<" Rhs: <"<< std::get<1>(phiRhs)->getName() <<"->"<<std::get<2>(phiRhs) <<", "<<std::get<3>(phiRhs)<<">";
               else 
    	 	errs() <<" Rhs: <"<< std::get<1>(phiRhs)->getName() <<"."<<std::get<2>(phiRhs) <<","<<std::get<3>(phiRhs)<<">";
	    }
	    else
		errs() <<" Rhs: <"<< std::get<1>(phiRhs)->getName()<<","<<std::get<3>(phiRhs)<<">";
	 }//end for
	 break;	
        }
        if (Lhs.second == 999/*Obj.getUse()*/) { 
	 Instruction *INST = getInstforIndx(i.first);  
	 std::vector<std::tuple<int, Token*, std::string,int>> vecIcmpRhsOpd = objStruct.fetchIcmpRhsOpd(INST);
	 for (auto p = 0; p < vecIcmpRhsOpd.size(); p++) { 
	    std::tuple<int, Token*, std::string, int> icmpRhs = vecIcmpRhsOpd[p];
	    if (std::get<2>(icmpRhs) != "") {
            if (std::get<1>(icmpRhs)->isValPointerType())
    	 	errs() <<" Rhs: <"<< std::get<1>(icmpRhs)->getName() <<"->"<<std::get<2>(icmpRhs) <<", "<<std::get<3>(icmpRhs)<<">";
            else 
    	 	errs() <<" Rhs: <"<< std::get<1>(icmpRhs)->getName() <<"."<<std::get<2>(icmpRhs) <<","<<std::get<3>(icmpRhs)<<">";
	    }
	    else
		errs() <<" Rhs: <"<< std::get<1>(icmpRhs)->getName()<<","<<std::get<3>(icmpRhs)<<">";
	  }
	  break;	
	}//end if 999

        if (Obj.getFieldRhs() and rhsVal.first->isValPointerType()) 
	   errs() <<" Rhs: <"<< rhsVal.first->getName() <<"->"<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else if (Obj.getFieldRhs() and !rhsVal.first->isValPointerType()) 
	   errs() <<" Rhs: <"<< rhsVal.first->getName() <<"."<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else if (Obj.getBitcast() and !rhsVal.first->isValPointerType()) 
	   errs() <<" Rhs: <"<< rhsVal.first->getName() <<"."<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else if (Obj.getBitcast() and rhsVal.first->isValPointerType()) 
	   errs() <<" Rhs: <"<< rhsVal.first->getName() <<"->"<<objStruct.getStructFieldIndxRhs(i.first) << ", "<<rhsVal.second <<">"; 
        else
	   errs() <<" Rhs: <"<< rhsVal.first->getName() << ", "<<rhsVal.second <<">"; 	 
     }//end inner for
   }//end outer for
   errs() << "\n";			
}

